<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="StudySettings">
    <StudyTaskManager>
      <option name="VERSION" value="14" />
      <option name="myUserTests">
        <map />
      </option>
      <option name="course">
        <HyperskillCourse>
          <option name="authors">
            <list />
          </option>
          <option name="courseMode" value="Study" />
          <option name="customPresentableName" />
          <option name="description" value="Games can help you kill time when you’re bored - and here we don’t mean smartphone games, but the classic paper-and-pencil ones. However, we aren’t inviting you to kill time: on the contrary, we offer to write a game and improve your programming skills. In this project, you will work on the Hangman, a game where the player is supposed to guess a word letter by letter. Make a program that plays Hangman with you - and good luck with the guessing!&lt;br/&gt;&lt;br/&gt;Learn more at &lt;a href=&quot;https://hyperskill.org&quot;&gt;https://hyperskill.org/projects/69&lt;/a&gt;" />
          <option name="environment" value="" />
          <option name="fromZip" value="false" />
          <option name="id" value="0" />
          <option name="index" value="-1" />
          <option name="language" value="Python" />
          <option name="languageCode" value="en" />
          <option name="name" value="Hangman" />
          <option name="stages">
            <list>
              <HyperskillStage>
                <option name="id" value="372" />
                <option name="stepId" value="6082" />
                <option name="title" value="Hello, Hangman" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="373" />
                <option name="stepId" value="6083" />
                <option name="title" value="I want to play a game" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="374" />
                <option name="stepId" value="6084" />
                <option name="title" value="Make your choice" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="375" />
                <option name="stepId" value="6085" />
                <option name="title" value="Help is on the way" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="376" />
                <option name="stepId" value="6086" />
                <option name="title" value="Keep trying" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="377" />
                <option name="stepId" value="6087" />
                <option name="title" value="The value of life" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="378" />
                <option name="stepId" value="6088" />
                <option name="title" value="Error!" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="379" />
                <option name="stepId" value="6089" />
                <option name="title" value="Menu, please" />
              </HyperskillStage>
            </list>
          </option>
          <option name="stepikChangeStatus" value="Up to date" />
          <option name="taskToTopics">
            <map>
              <entry key="0">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="333" />
                      <option name="theoryId" value="5204" />
                      <option name="title" value="Introduction to Python" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="336" />
                      <option name="theoryId" value="5208" />
                      <option name="title" value="The first program" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="1">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="335" />
                      <option name="theoryId" value="5233" />
                      <option name="title" value="Multi-line programs" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="402" />
                      <option name="theoryId" value="5879" />
                      <option name="title" value="PEP 8" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="403" />
                      <option name="theoryId" value="6081" />
                      <option name="title" value="Comments" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="394" />
                      <option name="theoryId" value="5852" />
                      <option name="title" value="Basic data types" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="396" />
                      <option name="theoryId" value="5859" />
                      <option name="title" value="Variables" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="398" />
                      <option name="theoryId" value="5865" />
                      <option name="title" value="Integer arithmetic" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="415" />
                      <option name="theoryId" value="6025" />
                      <option name="title" value="Boolean logic" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="397" />
                      <option name="theoryId" value="5885" />
                      <option name="title" value="Naming variables" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="404" />
                      <option name="theoryId" value="5913" />
                      <option name="title" value="Taking input" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="399" />
                      <option name="theoryId" value="5872" />
                      <option name="title" value="Program with numbers" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="405" />
                      <option name="theoryId" value="5920" />
                      <option name="title" value="Comparisons" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="406" />
                      <option name="theoryId" value="5953" />
                      <option name="title" value="If statement" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="407" />
                      <option name="theoryId" value="5932" />
                      <option name="title" value="Else statement" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="408" />
                      <option name="theoryId" value="5926" />
                      <option name="title" value="Elif statement" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="2">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="395" />
                      <option name="theoryId" value="5979" />
                      <option name="title" value="List" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="416" />
                      <option name="theoryId" value="6031" />
                      <option name="title" value="Operations with list" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="400" />
                      <option name="theoryId" value="5891" />
                      <option name="title" value="Invoking a function" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="414" />
                      <option name="theoryId" value="6019" />
                      <option name="title" value="Load module" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="448" />
                      <option name="theoryId" value="6263" />
                      <option name="title" value="Random" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="4">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="429" />
                      <option name="theoryId" value="6065" />
                      <option name="title" value="For loop" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="5">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="409" />
                      <option name="theoryId" value="5940" />
                      <option name="title" value="While loop" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="453" />
                      <option name="theoryId" value="6302" />
                      <option name="title" value="Loop control statements" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="6">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="418" />
                      <option name="theoryId" value="6047" />
                      <option name="title" value="Program execution" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="419" />
                      <option name="theoryId" value="6052" />
                      <option name="title" value="Errors" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
            </map>
          </option>
          <option name="updateDate" value="0" />
          <option name="hyperskillProject">
            <HyperskillProject>
              <option name="description" value="Games can help you kill time when you’re bored - and here we don’t mean smartphone games, but the classic paper-and-pencil ones. However, we aren’t inviting you to kill time: on the contrary, we offer to write a game and improve your programming skills. In this project, you will work on the Hangman, a game where the player is supposed to guess a word letter by letter. Make a program that plays Hangman with you - and good luck with the guessing!" />
              <option name="id" value="69" />
              <option name="ideFiles" value="https://stepik.org/media/attachments/lesson/225053/additional_files.json" />
              <option name="language" value="python" />
              <option name="title" value="Hangman" />
              <option name="useIde" value="true" />
            </HyperskillProject>
          </option>
          <option name="items">
            <list>
              <FrameworkLesson>
                <option name="currentTaskIndex" value="5" />
                <option name="customPresentableName" />
                <option name="id" value="0" />
                <option name="index" value="1" />
                <option name="name" value="Hangman" />
                <option name="stepikChangeStatus" value="Up to date" />
                <option name="updateDate" value="0" />
                <option name="unitId" value="0" />
                <option name="items">
                  <list>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Hangman&lt;/strong&gt; is a popular yet grim intellectual game. A cruel computer hides a word from you. Letter by letter you try to guess it. If you fail, you'll be hanged, if you win, you'll survive. See also: &lt;a href=&quot;https://en.wikipedia.org/wiki/Hangman_(game)&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;&#10;&#10;&lt;p&gt;You probably played the game at least once in your life; now you can actually create this game yourself!&lt;/p&gt;&#10;&#10;&lt;h2&gt;The game rules overview &lt;/h2&gt;&#10;&#10;&lt;p&gt;Let's have a brief overview of what you are going to build during this project. Here is what the gameplay should look like:&lt;/p&gt;&#10;&#10;&lt;ol&gt;&#10;&#9;&lt;li&gt;In the main menu, a player can choose to either play or exit the game;&lt;/li&gt;&#10;&#9;&lt;li&gt;If the user chooses to play, the computer picks a word from a list: this will be the riddle;&lt;/li&gt;&#10;&#9;&lt;li&gt;The computer asks the player to enter a letter that (s)he thinks is in the word;&lt;/li&gt;&#10;&#9;&lt;li&gt;If there's no such letter in the word and this letter hasn't been tried before, the computer counts it as a miss. A player can afford only up to 8 misses before the game is over;&lt;/li&gt;&#10;&#9;&lt;li&gt;If the letter does occur in the word, the computer notifies the player. If there are letters left to guess, the computer invites the player to go on.&lt;/li&gt;&#10;&#9;&lt;li&gt;When the entire word is uncovered, it's a victory! The game calculates the final score and goes back to the main menu.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&#10;&lt;p&gt;It may sound complex, but the project is split into small stages with hints to see you through. The final product is sure to be replayable and quite engaging!&lt;/p&gt;&#10;&#10;&lt;h2&gt;Your game announcement&lt;/h2&gt;&#10;&#10;&lt;p&gt;Let's start with an announcement that will greet the player. You already know how to print something using Python: try to apply your knowledge to intrigue your friends with your game announcement!&lt;/p&gt;&#10;&#10;&lt;h2&gt;Output example &lt;/h2&gt;&#10;&#10;&lt;p&gt;In this stage you should &lt;strong&gt;write a program &lt;/strong&gt;that prints the lines as shown in the example below:&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;The game will be available soon.&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/372/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6082" />
                      <option name="index" value="1" />
                      <option name="name" value="Hello, Hangman" />
                      <option name="record" value="1" />
                      <option name="status" value="Solved" />
                      <option name="stepikChangeStatus" value="Info and Content changed" />
                      <option name="files">
                        <map>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;&#10;&#10;right_str = &quot;&quot;&quot;H A N G M A N&#10;The game will be available soon.&quot;&quot;&quot;&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        return [TestCase(attach=right_str)]&#10;&#10;    def check(self, reply: str, attach: str) -&gt; CheckResult:&#10;        if reply.strip() == attach.strip():&#10;            return CheckResult.true()&#10;        return CheckResult.false(&#10;            &quot;You should print output exactly like in the example&quot;)&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hangman/hangman.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="hangman/hangman.py" />
                                <option name="text" value="# Write your code here&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561122730000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Guess the word&lt;/h2&gt;&#10;&#10;&lt;p&gt;At this stage, you will create a real game. It will be simple, but there will be two possible outcomes (you can see in the examples below how they look like). Let's first print a welcome message and then ask a player to guess the word we set for the game. If our player manages to guess the exact word, the game reports &quot;win&quot;; otherwise it will &quot;hang&quot; the player.&lt;/p&gt;&#10;&#10;&lt;p&gt;You should print &lt;code&gt;You survived!&lt;/code&gt; if the user guessed the word and &lt;code&gt;You are hanged!&lt;/code&gt; otherwise. By the way, the word &lt;code&gt;python&lt;/code&gt; should be the correct word to win the game.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Input and output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 1&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word: python&#10;You survived!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 2&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word: java&#10;You are hanged!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;where &lt;code&gt;Guess the word:&lt;/code&gt; is an input invitation message.&lt;/p&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/373/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6083" />
                      <option name="index" value="2" />
                      <option name="name" value="I want to play a game" />
                      <option name="record" value="2" />
                      <option name="status" value="Failed" />
                      <option name="stepikChangeStatus" value="Info and Content changed" />
                      <option name="files">
                        <map>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        return [&#10;            TestCase(stdin='python', attach=(True, 'python')),&#10;            TestCase(stdin='java', attach=(False, 'java')),&#10;            TestCase(stdin='pyton', attach=(False, '')),&#10;            TestCase(stdin='python', attach=(True, '')),&#10;        ]&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;&#10;        right_ans, guess = attach&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        if survived in reply and hanged in reply:&#10;            return CheckResult.false(&#10;                f'Looks like your output contains both \&quot;{survived}\&quot;'&#10;                f' and \&quot;{hanged}\&quot;. You should output only one of them.')&#10;&#10;        if survived not in reply and hanged not in reply:&#10;            return CheckResult.false(&#10;                f'Looks like your output doesn\'t contain neither \&quot;{survived}\&quot;'&#10;                f' nor \&quot;{hanged}\&quot;. You should output one of them.')&#10;&#10;        if right_ans:&#10;            if survived in reply:&#10;                return CheckResult.true()&#10;&#10;            if guess:&#10;                return CheckResult.false(&#10;                    'input: ' + 'python\n'&#10;                    'correct output: ' + survived&#10;                )&#10;&#10;            else:&#10;                return CheckResult.false()&#10;&#10;        else:&#10;            if hanged in reply:&#10;                return CheckResult.true()&#10;&#10;            if guess:&#10;                return CheckResult.false(&#10;                    'input: ' + 'java\n'&#10;                    'correct output: ' + hanged&#10;                )&#10;&#10;            else:&#10;                return CheckResult.false()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hangman/hangman.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="hangman/hangman.py" />
                                <option name="text" value="print(&quot;&quot;&quot;H A N G M A N\nThe game will be available soon.&quot;&quot;&quot;)&#10;&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561122731000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Guess a random word&lt;/h2&gt;&#10;&#10;&lt;p&gt;If there is a predefined word, the game isn't replayable: you already know the word, so it makes no sense to guess it. At this stage, let's make the game more challenging by choosing a word from a special list with a variety of options. This way, our game won't be just a one-time entertainment.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Input and output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;Using the following word list: &lt;code&gt;'python', 'java', 'kotlin', 'javascript'&lt;/code&gt; ,  program the game to choose a random word from it. You can enter more words, but let's stick to these four for now.&lt;/p&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 1&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word: python&#10;You survived!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;In case the computer randomly chose &lt;code&gt;python&lt;/code&gt; from the list.&lt;/p&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 2&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word: python&#10;You are hanged!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;In case the computer randomly chose something other than &lt;code&gt;python&lt;/code&gt; from the list.&lt;/p&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 3&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word: C#&#10;You are hanged!&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/374/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6084" />
                      <option name="index" value="3" />
                      <option name="name" value="Make your choice" />
                      <option name="record" value="3" />
                      <option name="status" value="Failed" />
                      <option name="stepikChangeStatus" value="Info and Content changed" />
                      <option name="files">
                        <map>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import accept, wrong&#10;&#10;from random import shuffle&#10;&#10;&#10;description_list = ['python', 'java', 'kotlin', 'javascript']&#10;out_of_description = ['clojure', 'haskell', 'typescript', 'assembler']&#10;&#10;catch = {i: 0 for i in description_list}&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests = []&#10;&#10;        for word in description_list + out_of_description:&#10;            for i in range(100):&#10;                tests += [TestCase(stdin=word, attach=word)]&#10;&#10;        shuffle(tests)&#10;&#10;        word = 'last'&#10;        tests += [TestCase(stdin=word, attach=word)]&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        is_survived = survived in reply&#10;        is_hanged = hanged in reply&#10;&#10;        if is_survived and is_hanged:&#10;            return wrong(&#10;                f'Looks like your output contains both \&quot;{survived}\&quot;'&#10;                f' and \&quot;{hanged}\&quot;. You should output only one of them.'&#10;            )&#10;&#10;        if not is_survived and not is_hanged:&#10;            return wrong(&#10;                f'Looks like your output doesn\'t contain neither \&quot;{survived}\&quot;'&#10;                f' nor \&quot;{hanged}\&quot;. You should output one of them.'&#10;            )&#10;&#10;        if attach in out_of_description:&#10;            if is_survived:&#10;                return wrong(&#10;                    f'Input contains a word out of the '&#10;                    f'list form the description but the '&#10;                    f'program output \&quot;{survived}\&quot;'&#10;                )&#10;            else:&#10;                return accept()&#10;&#10;        elif attach in description_list:&#10;            catch[attach] += is_survived&#10;            return accept()&#10;&#10;        else:&#10;            if any(v == 0 for v in catch.values()):&#10;                return wrong(&#10;                    &quot;Looks like your program is not using &quot;&#10;                    &quot;all of the words to guess from the list in description&quot;&#10;                )&#10;            else:&#10;                return accept()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hangman/hangman.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="hangman/hangman.py" />
                                <option name="text" value="_str = input(&quot;Guess the word: &quot;)&#10;if _str == &quot;python&quot;:&#10;    print(&quot;You survived!&quot;)&#10;else:&#10;    print(&quot;You are hanged!&quot;)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hangman/self_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="hangman/self_test.py" />
                                <option name="text" value="" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561122732000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Guess a word with a hint&lt;/h2&gt;&#10;&#10;&lt;p&gt;Now our game has become quite hard, and your chances of guessing the word depend on the size of the list. In our case with four words, there is only a 25% chance, so let's have mercy on the player and add a hint for them.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Input and output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;As in the previous stage, you should use the following word list: &lt;code&gt;'python', 'java', 'kotlin', 'javascript'&lt;/code&gt;&lt;/p&gt;&#10;&#10;&lt;p&gt;Let the game show the &lt;strong&gt;first 3 letters&lt;/strong&gt; after the computer chose a word from the list.&lt;br&gt;&#10;Hidden letters should be replaced with dashes (&lt;code&gt;&quot;-&quot;&lt;/code&gt;).&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word jav-: java&#10;You survived!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word pyt---: pytnoh&#10;You are hanged!&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/375/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6085" />
                      <option name="index" value="4" />
                      <option name="name" value="Help is on the way" />
                      <option name="record" value="4" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import accept, wrong&#10;&#10;from random import shuffle&#10;&#10;&#10;description_list = ['python', 'java', 'kotlin', 'javascript']&#10;out_of_description = ['clojure', 'haskell', 'typescript', 'assembler']&#10;&#10;catch = {i: 0 for i in description_list}&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests = []&#10;&#10;        for word in description_list + out_of_description:&#10;            for i in range(100):&#10;                tests += [TestCase(stdin=word, attach=word)]&#10;&#10;        shuffle(tests)&#10;&#10;        word = 'last'&#10;        tests += [TestCase(stdin=word, attach=word)]&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        is_survived = survived in reply&#10;        is_hanged = hanged in reply&#10;&#10;        if is_survived and is_hanged:&#10;            return wrong(&#10;                f'Looks like your output contains both \&quot;{survived}\&quot;'&#10;                f' and \&quot;{hanged}\&quot;. You should output only one of them.'&#10;            )&#10;&#10;        if not is_survived and not is_hanged:&#10;            return wrong(&#10;                f'Looks like your output doesn\'t contain neither \&quot;{survived}\&quot;'&#10;                f' nor \&quot;{hanged}\&quot;. You should output one of them.'&#10;            )&#10;&#10;        if attach in out_of_description:&#10;            if is_survived:&#10;                return wrong(&#10;                    f'Input contains a word out of the '&#10;                    f'list form the description but the '&#10;                    f'program output \&quot;{survived}\&quot;'&#10;                )&#10;            else:&#10;                return accept()&#10;&#10;        elif attach in description_list:&#10;&#10;            if is_survived:&#10;                hidden_attach = attach[:3] + '-'*len(attach[3:])&#10;                if hidden_attach not in reply:&#10;                    return wrong(&#10;                        f'Program guessed the word \&quot;{attach}\&quot; '&#10;                        f'and should output clue \&quot;{hidden_attach}\&quot; '&#10;                        f'but this line is not in the output'&#10;                    )&#10;&#10;            catch[attach] += is_survived&#10;            return accept()&#10;&#10;        else:&#10;            if any(v == 0 for v in catch.values()):&#10;                return wrong(&#10;                    &quot;Looks like your program is not using &quot;&#10;                    &quot;all of the words to guess from the list in description&quot;&#10;                )&#10;            else:&#10;                return accept()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hangman/hangman.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hangman/hangman.py" />
                                <option name="text" value="import random&#10;&#10;&#10;class Hangman:&#10;    possible_words = {'python', 'java', 'kotlin', 'javascript'}&#10;&#10;    def test(self):&#10;        if random.choice(tuple(self.possible_words)) ==\&#10;                input(&quot;Guess the word: &quot;).casefold():&#10;            print(&quot;You survived!&quot;)&#10;        else:&#10;            print(&quot;You are hanged!&quot;)&#10;&#10;&#10;if __name__ == '__main__':&#10;    print(&quot;H A N G M A N&quot;)&#10;    Hangman().test()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561122734000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Letter by letter&lt;/h2&gt;&#10;&#10;&lt;p&gt;Let's make the game iterative. It's time to make it resemble the classical Hangman a bit more: a player should guess letters in the word instead of typing the entire word at once. If the player guesses a letter, it should be uncovered in the word. For now, start with the defeat case and add 8 tries to guess a letter that appears in the word. When the player runs out of attempts, the game ends.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Input and output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;A player should have 8 tries and enter letters. If the letter doesn't occur in the word, the computer takes one try away, even if the user already inputted this letter before. If the player doesn't have any more attempts, the game should end and the program should show a losing message. Otherwise, the player can continue to input letters.&lt;/p&gt;&#10;&#10;&lt;p&gt;Notice that if a player has more tries but he actually guessed the word, it doesn't mean anything. Determining the winning conditions will be in the next stage, in this stage you should print how well user guesses the word on every user attempt to input a letter. Try to match your input with the example below (it is important for testing to print a new line before printing guessed letters).&lt;/p&gt;&#10;&#10;&lt;p&gt;Also, use the following word list: &lt;code&gt;'python', 'java', 'kotlin', 'javascript'&lt;/code&gt; so your program can be tested more reliably.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;&#10;----------&#10;Input a letter: a&#10;&#10;-a-a------&#10;Input a letter: i&#10;&#10;-a-a---i--&#10;Input a letter: o&#10;No such letter in the word&#10;&#10;-a-a---i--&#10;Input a letter: o&#10;No such letter in the word&#10;&#10;-a-a---i--&#10;Input a letter: p&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: p&#10;&#10;-a-a---ip-&#10;Input a letter: h&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: k&#10;No such letter in the word&#10;&#10;Thanks for playing!&#10;We'll see how well you did in the next stage&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;&#10;----&#10;Input a letter: j&#10;&#10;j---&#10;Input a letter: i&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: g&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: o&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: a&#10;&#10;ja-a&#10;Input a letter: v&#10;&#10;java&#10;Input a letter: a&#10;&#10;java&#10;Input a letter: j&#10;&#10;Thanks for playing!&#10;We'll see how well you did in the next stage&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/376/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6086" />
                      <option name="index" value="5" />
                      <option name="name" value="Keep trying" />
                      <option name="record" value="5" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import accept, wrong&#10;&#10;from random import shuffle&#10;from string import ascii_lowercase&#10;&#10;&#10;description_list = ['python', 'java', 'kotlin', 'javascript']&#10;out_of_description = ['clojure', 'haskell', 'typescript', 'assembler']&#10;&#10;catch = {i: 0 for i in description_list}&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests = []&#10;&#10;        for word in description_list + out_of_description + [ascii_lowercase]:&#10;            for i in range(100):&#10;                words = [w for w in word * 2]&#10;                shuffle(words)&#10;                inputs = '\n'.join(words)&#10;                tests += [TestCase(stdin=inputs, attach=words)]&#10;&#10;        shuffle(tests)&#10;&#10;        word = 'l\na\ns\nt\n' * 2&#10;        tests += [TestCase(stdin=word, attach='last')]&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;&#10;        tries = [i.strip() for i in reply.strip().split('\n\n') if len(i.strip())]&#10;&#10;        if len(tries) == 0:&#10;            return wrong(&#10;                &quot;Seems like you didn't print the game or not separated output properly&quot;&#10;                &quot;(there need to be an empty line between guessing attempts)&quot;&#10;            )&#10;&#10;        if &quot;Input a letter&quot; not in reply:&#10;            return wrong(&#10;                &quot;Input doesn't contain any \&quot;Input a letter\&quot; lines&quot;&#10;            )&#10;&#10;        if 'for playing' not in tries[-1]:&#10;            return wrong(&#10;                &quot;Last block should contain text \&quot;Thanks for playing!\&quot;&quot;&#10;            )&#10;&#10;        elif &quot;Input a letter&quot; in tries[-1]:&#10;            return wrong(&#10;                &quot;Last block should not contain text \&quot;Input a letter\&quot;&quot;&#10;            )&#10;&#10;        tries = tries[:-1]&#10;&#10;        full_blocks = [try_ for try_ in tries if len(try_.splitlines()) &gt; 1]&#10;        blocks = [block.splitlines()[0].strip() for block in full_blocks]&#10;&#10;        for full_block, block in zip(full_blocks, blocks):&#10;            if ' ' in block:&#10;                return wrong(&#10;                    'Cannot parse this block - it contains spaces '&#10;                    'in the first line, but shouldn\'t\n\n'&#10;                    f'{full_block}'&#10;                )&#10;&#10;        if len(blocks) &lt; 8:&#10;            return wrong(&#10;                f'There are less than 8 blocks of output. '&#10;                f'Did you separate each guess attempt with a new line?'&#10;            )&#10;&#10;        lengths = set(len(i) for i in blocks)&#10;&#10;        str_lengths = []&#10;        for i, curr_len in enumerate(lengths, 1):&#10;            for curr_block in blocks:&#10;                if curr_len == len(curr_block):&#10;                    str_lengths += [f'{i}. {curr_block}']&#10;                    break&#10;&#10;        str_lengths = '\n'.join(str_lengths)&#10;&#10;        if len(lengths) &gt; 1:&#10;            return wrong(&#10;                f'Every line with guessed letters should be the same length as others.\n'&#10;                f'Found lines with guessed letters:\n{str_lengths}'&#10;            )&#10;&#10;        correct = '-'*len(blocks[0])&#10;&#10;        if blocks[0] != correct:&#10;            return wrong(&#10;                f'The first guess should only contain dashes: \n'&#10;                f'{correct}\n'&#10;                f'Your first guess:\n'&#10;                f'{blocks[0]}'&#10;            )&#10;&#10;        for letter, prev, next in zip(attach, blocks[0:], blocks[1:]):&#10;&#10;            cond1 = (&#10;                (letter not in prev) and&#10;                (letter in next) and&#10;                (set(next) - set(prev) != set(letter))&#10;            )&#10;&#10;            cond2 = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            cond3 = (&#10;                (letter in prev) and&#10;                (letter in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            if cond1 or cond2 or cond3:&#10;                return wrong(&#10;                    f'This transition is incorrect:\n'&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}'&#10;                )&#10;&#10;        if '-' not in blocks[-1]:&#10;            catch[blocks[-1]] += 1&#10;&#10;        if attach == 'last':&#10;            if catch.values() == 0:&#10;                return wrong(&#10;                    &quot;Looks like your program is not using &quot;&#10;                    &quot;all of the words to guess from the list in description&quot;&#10;                )&#10;&#10;        return accept()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hangman/hangman.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hangman/hangman.py" />
                                <option name="text" value="import random&#10;&#10;&#10;class Hangman:&#10;    possible_words = {'python', 'java', 'kotlin', 'javascript'}&#10;&#10;    def test(self):&#10;        guessed_word = random.choice(tuple(self.possible_words))&#10;        some = &quot;-&quot; * len(guessed_word)&#10;        some = guessed_word[:3] + some[3:]&#10;        if guessed_word ==\&#10;                input(&quot;Guess the word {}: &quot;.format(some)).casefold():&#10;            print(&quot;You survived!&quot;)&#10;        else:&#10;            print(&quot;You are hanged!&quot;)&#10;&#10;&#10;if __name__ == '__main__':&#10;    print(&quot;H A N G M A N&quot;)&#10;    Hangman().test()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561122735000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Add the victory condition&lt;/h2&gt;&#10;&#10;&lt;p&gt;The recent version of the game is not as fun until we don't handle the player's victory. A player wins when all the letters are guessed and there are still some tries left (except the player uses his last try and actually guesses the word, he's lucky then!).&lt;/p&gt;&#10;&#10;&lt;p&gt;Notice that, in the previous stage, the user has only 8 attempts to guess letters. The number of attempts was decreasing despite the fact that the user guessed one of the hidden letters in the word! It needs to be changed - now the number of attempts should decrease only if there are no words to uncover. And yes, if the word to guess is &lt;code&gt;-a-a&lt;/code&gt; at the moment and the user printed &lt;code&gt;a&lt;/code&gt; you should count this as a fail and reduce the number of attempts by 1 (later we'll fix it in favor of the user).&lt;/p&gt;&#10;&#10;&lt;p&gt;Print &lt;code&gt;No such letter in the word&lt;/code&gt; if the word guessed by the program doesn't contain this letter.&lt;/p&gt;&#10;&#10;&lt;p&gt;Print &lt;code&gt;No improvements&lt;/code&gt; if the guessed word contains this letter but the user tried this letter before.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Input and output example&lt;/h2&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;&#10;----------&#10;Input a letter: a&#10;&#10;-a-a------&#10;Input a letter: i&#10;&#10;-a-a---i--&#10;Input a letter: o&#10;No such letter in the word&#10;&#10;-a-a---i--&#10;Input a letter: o&#10;No such letter in the word&#10;&#10;-a-a---i--&#10;Input a letter: p&#10;&#10;-a-a---ip-&#10;Input a letter: p&#10;No improvements&#10;&#10;-a-a---ip-&#10;Input a letter: h&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: k&#10;No such letter in the word&#10;You are hanged!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;&#10;----&#10;Input a letter: j&#10;&#10;j---&#10;Input a letter: i&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: g&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: a&#10;&#10;ja-a&#10;Input a letter: v&#10;&#10;java&#10;You guessed the word!&#10;You survived!&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/377/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6087" />
                      <option name="index" value="6" />
                      <option name="name" value="The value of life" />
                      <option name="record" value="-1" />
                      <option name="status" value="Failed" />
                      <option name="stepikChangeStatus" value="Info and Content changed" />
                      <option name="files">
                        <map>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import accept, wrong&#10;&#10;from random import shuffle&#10;from string import ascii_lowercase&#10;&#10;&#10;description_list = ['python', 'java', 'kotlin', 'javascript']&#10;out_of_description = ['clojure', 'haskell', 'typescript', 'assembler']&#10;&#10;catch = {i: 0 for i in description_list}&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests = []&#10;&#10;        for word in description_list + out_of_description + [ascii_lowercase]:&#10;            for i in range(100):&#10;                words = [w for w in word * 30]&#10;                shuffle(words)&#10;                inputs = '\n'.join(words)&#10;                tests += [TestCase(stdin=inputs, attach=words)]&#10;&#10;        shuffle(tests)&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;&#10;        tries = [i.strip() for i in reply.split('\n\n') if len(i.strip())]&#10;&#10;        if len(tries) == 0:&#10;            return wrong(&#10;                &quot;Seems like you didn't print the game or not separated output properly&quot;&#10;                &quot;(there need to be an empty line between guessing attempts)&quot;&#10;            )&#10;&#10;        full_blocks = [try_ for try_ in tries if len(try_.splitlines()) &gt; 1]&#10;        blocks = [block.splitlines()[0].strip() for block in full_blocks]&#10;&#10;        for full_block, block in zip(full_blocks, blocks):&#10;            if ' ' in block:&#10;                return wrong(&#10;                    'Cannot parse this block - it contains spaces '&#10;                    'in the first line, but shouldn\'t\n\n'&#10;                    f'{full_block}'&#10;                )&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        is_survived = survived in full_blocks[-1]&#10;        is_hanged = hanged in full_blocks[-1]&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        no_such_letter = 'No such letter in the word'&#10;        no_improvements = 'No improvements'&#10;&#10;        lengths = set(len(i) for i in blocks)&#10;&#10;        str_lengths = []&#10;        for i, curr_len in enumerate(lengths, 1):&#10;            for curr_block in blocks:&#10;                if curr_len == len(curr_block):&#10;                    str_lengths += [f'{i}. {curr_block}']&#10;                    break&#10;&#10;        str_lengths = '\n'.join(str_lengths)&#10;&#10;        if len(lengths) &gt; 1:&#10;            return wrong(&#10;                f'Every line with guessed letters should be the same length as others.\n'&#10;                f'Found lines with guessed letters:\n{str_lengths}'&#10;            )&#10;&#10;        correct = '-'*len(blocks[0])&#10;&#10;        if blocks[0] != correct:&#10;            return wrong(&#10;                f'The first guess should only contain dashes: \n'&#10;                f'{correct}\n'&#10;                f'Your first guess:\n'&#10;                f'{blocks[0]}'&#10;            )&#10;&#10;        wrong_count = 0&#10;&#10;        if is_hanged:&#10;            blocks += [blocks[-1]]&#10;            full_blocks += [full_blocks[-1]]&#10;&#10;        for letter, prev, next, prev_full, next_full in zip(&#10;                attach, blocks[0:], blocks[1:], full_blocks[0:], full_blocks[1:]):&#10;&#10;            if prev == next:&#10;                wrong_count += 1&#10;&#10;            detect_no_such_letter = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next == prev)&#10;            )&#10;&#10;            if detect_no_such_letter and no_such_letter not in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{no_such_letter}\&quot; message, but should be'&#10;                )&#10;            elif not detect_no_such_letter and no_such_letter in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{no_such_letter}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            detect_no_improvements = (&#10;                (letter in prev) and&#10;                (letter in next) and&#10;                (next == prev)&#10;            )&#10;&#10;            if detect_no_improvements and no_improvements not in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{no_improvements}\&quot; message, but should be'&#10;                )&#10;            elif not detect_no_improvements and no_improvements in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{no_improvements}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            cond1 = (&#10;                (letter not in prev) and&#10;                (letter in next) and&#10;                (set(next) - set(prev) != set(letter))&#10;            )&#10;&#10;            cond2 = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            cond3 = (&#10;                (letter in prev) and&#10;                (letter in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            if cond1 or cond2 or cond3:&#10;                return wrong(&#10;                    f'This transition is incorrect:\n'&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}'&#10;                )&#10;&#10;        if is_survived and is_hanged:&#10;            return wrong(&#10;                f'Looks like your output contains both \&quot;{survived}\&quot;'&#10;                f' and \&quot;{hanged}\&quot;. You should output only one of them.'&#10;            )&#10;&#10;        if not is_survived and not is_hanged:&#10;            return wrong(&#10;                f'Looks like your output doesn\'t contain neither \&quot;{survived}\&quot;'&#10;                f' nor \&quot;{hanged}\&quot;. You should output one of them.'&#10;            )&#10;&#10;        if is_hanged:&#10;            if wrong_count != 8:&#10;                return wrong(&#10;                    f'User was hanged after {wrong_count} wrong guesses, but should after 8. '&#10;                    f'Notice, that in this stage &quot;No improvements&quot; also counts as wrong guess.'&#10;                )&#10;            else:&#10;                return accept()&#10;&#10;        if is_survived:&#10;            if wrong_count &gt;= 8:&#10;                return wrong(&#10;                    f'User survived but have {wrong_count} wrong guesses. He should be hanged'&#10;                )&#10;            else:&#10;                return accept()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hangman/hangman.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="hangman/hangman.py" />
                                <option name="text" value="" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hangman/__pycache__/hangman.cpython-36.pyc">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hangman/__pycache__/hangman.cpython-36.pyc" />
                                <option name="text" value="" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561122736000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Polishing the gameplay&lt;/h2&gt;&#10;&#10;&lt;p&gt;Now that we are done with the basics, let's work on some details.&lt;/p&gt;&#10;&#10;&lt;p&gt;Notice that in the previous stage if the user entered the same letter twice the program always reduces the number of attempts - regardless if this was a correct letter or not. But it is not fair to the user, isn't it? He gains no additional information about the situation on the field yet the program still reduces his attempts count. This time if the user enters the same letter twice then the program should output &lt;code&gt;You already typed this letter&lt;/code&gt; .&lt;/p&gt;&#10;&#10;&lt;p&gt;Also, you should check is the user print English lowercase letter or not. If not, the program should print &lt;code&gt;It is not an ASCII lowercase letter&lt;/code&gt; . &lt;/p&gt;&#10;&#10;&lt;p&gt;Also, you should check if the user printed exactly one letter. If not, the program should print &lt;code&gt;You should print a single letter&lt;/code&gt; . Remember that zero is also not one!&lt;/p&gt;&#10;&#10;&lt;p&gt;Note, that all these three errors should not reduce attempts count.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Input and output example&lt;/h2&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;&#10;----------&#10;Input a letter: a&#10;&#10;-a-a------&#10;Input a letter: i&#10;&#10;-a-a---i--&#10;Input a letter: o&#10;No such letter in the word&#10;&#10;-a-a---i--&#10;Input a letter: o&#10;You already typed this letter&#10;&#10;-a-a---i--&#10;Input a letter: p&#10;&#10;-a-a---ip-&#10;Input a letter: p&#10;You already typed this letter&#10;&#10;-a-a---ip-&#10;Input a letter: h&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: k&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: a&#10;You already typed this letter&#10;&#10;-a-a---ip-&#10;Input a letter: z&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: t&#10;&#10;-a-a---ipt&#10;Input a letter: x&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: b&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: d&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: w&#10;No such letter in the word&#10;You are hanged!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;&#10;----&#10;Input a letter: j&#10;&#10;j---&#10;Input a letter: i&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: +&#10;It is not an ASCII lowercase letter&#10;&#10;j---&#10;Input a letter: A&#10;It is not an ASCII lowercase letter&#10;&#10;j---&#10;Input a letter: ii&#10;You should print a single letter&#10;&#10;j---&#10;Input a letter: ++&#10;You should print a single letter&#10;&#10;j---&#10;Input a letter:&#10;You should print a single letter&#10;&#10;j---&#10;Input a letter: g&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: a&#10;&#10;ja-a&#10;Input a letter: v&#10;You guessed the word java!&#10;You survived!&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/378/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6088" />
                      <option name="index" value="7" />
                      <option name="name" value="Error!" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import accept, wrong&#10;&#10;from random import shuffle, randint&#10;from string import ascii_lowercase, ascii_letters, punctuation, digits&#10;&#10;&#10;description_list = ['python', 'java', 'kotlin', 'javascript']&#10;out_of_description = ['clojure', 'haskell', 'typescript', 'assembler']&#10;&#10;catch = {i: 0 for i in description_list}&#10;all_letters = ascii_letters + punctuation + digits&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests = []&#10;&#10;        for word in description_list + out_of_description + [ascii_lowercase]:&#10;            for i in range(100):&#10;                words = [w if randint(1, 100) &lt; 95 else w + w for w in word * 50 + all_letters]&#10;                shuffle(words)&#10;                inputs = '\n'.join(words)&#10;                tests += [TestCase(stdin=inputs, attach=words)]&#10;&#10;        shuffle(tests)&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;&#10;        tries = [i.strip() for i in reply.split('\n\n') if len(i.strip())]&#10;&#10;        if len(tries) == 0:&#10;            return wrong(&#10;                &quot;Seems like you didn't print the game or not separated output properly&quot;&#10;                &quot;(there need to be an empty line between guessing attempts)&quot;&#10;            )&#10;&#10;        full_blocks = [try_ for try_ in tries if len(try_.splitlines()) &gt; 1]&#10;        blocks = [block.splitlines()[0].strip() for block in full_blocks]&#10;&#10;        for full_block, block in zip(full_blocks, blocks):&#10;            if ' ' in block:&#10;                return wrong(&#10;                    'Cannot parse this block - it contains spaces '&#10;                    'in the first line, but shouldn\'t\n\n'&#10;                    f'{full_block}'&#10;                )&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        is_survived = survived in full_blocks[-1]&#10;        is_hanged = hanged in full_blocks[-1]&#10;&#10;        no_such_letter = 'No such letter in the word'&#10;        already_typed = 'You already typed this letter'&#10;        not_ascii = 'It is not an ASCII lowercase letter'&#10;        print_single = 'You should print a single letter'&#10;&#10;        lengths = set(len(i) for i in blocks)&#10;&#10;        str_lengths = []&#10;        for i, curr_len in enumerate(lengths, 1):&#10;            for curr_block in blocks:&#10;                if curr_len == len(curr_block):&#10;                    str_lengths += [f'{i}. {curr_block}']&#10;                    break&#10;&#10;        str_lengths = '\n'.join(str_lengths)&#10;&#10;        if len(lengths) &gt; 1:&#10;            return wrong(&#10;                f'Every line with guessed letters should be the same length as others.\n'&#10;                f'Found lines with guessed letters:\n{str_lengths}'&#10;            )&#10;&#10;        correct = '-'*len(blocks[0])&#10;&#10;        if blocks[0] != correct:&#10;            return wrong(&#10;                f'The first guess should only contain dashes: \n'&#10;                f'{correct}\n'&#10;                f'Your first guess:\n'&#10;                f'{blocks[0]}'&#10;            )&#10;&#10;        wrong_count = 0&#10;        typed_letters = set()&#10;        inputs = ''&#10;&#10;        if is_hanged:&#10;            blocks += [blocks[-1]]&#10;            full_blocks += [full_blocks[-1]]&#10;&#10;        for letter, prev, next, prev_full, next_full in zip(&#10;                attach, blocks[0:], blocks[1:], full_blocks[0:], full_blocks[1:]):&#10;&#10;            # ---&#10;            detect_not_one = len(letter) != 1&#10;&#10;            if detect_not_one and print_single not in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{print_single}\&quot; message, but should be'&#10;                )&#10;            elif not detect_not_one and print_single in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{print_single}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            if detect_not_one:&#10;                continue&#10;&#10;            # ---&#10;            detect_not_ascii = letter not in ascii_lowercase&#10;&#10;            if detect_not_ascii and not_ascii not in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{not_ascii}\&quot; message, but should be'&#10;                )&#10;            elif not detect_not_ascii and not_ascii in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{not_ascii}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            if detect_not_ascii:&#10;                continue&#10;&#10;            inputs += '\n' + letter&#10;&#10;            # ---&#10;            detect_typed_letter = letter in typed_letters&#10;&#10;            if detect_typed_letter and already_typed not in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{already_typed}\&quot; message, but should be\n'&#10;                    f'Input letters: {inputs}'&#10;                )&#10;            elif not detect_typed_letter and already_typed in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{already_typed}\&quot; message, but shouldn\'t be'&#10;                    f'Input letters: {inputs}'&#10;                )&#10;&#10;            if detect_typed_letter:&#10;                continue&#10;&#10;            # ---&#10;            detect_no_such_letter = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next == prev) and not detect_typed_letter&#10;            )&#10;&#10;            if detect_no_such_letter and no_such_letter not in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{no_such_letter}\&quot; message, but should be'&#10;                )&#10;            elif not detect_no_such_letter and no_such_letter in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{no_such_letter}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            if detect_no_such_letter:&#10;                wrong_count += 1&#10;&#10;            typed_letters |= {letter}&#10;&#10;            cond1 = (&#10;                (letter not in prev) and&#10;                (letter in next) and&#10;                (set(next) - set(prev) != set(letter))&#10;            )&#10;&#10;            cond2 = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            cond3 = (&#10;                (letter in prev) and&#10;                (letter in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            if cond1 or cond2 or cond3:&#10;                return wrong(&#10;                    f'This transition is incorrect:\n'&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}'&#10;                )&#10;&#10;        if is_survived and is_hanged:&#10;            return wrong(&#10;                f'Looks like your output contains both \&quot;{survived}\&quot;'&#10;                f' and \&quot;{hanged}\&quot;. You should output only one of them.'&#10;            )&#10;&#10;        if not is_survived and not is_hanged:&#10;            return wrong(&#10;                f'Looks like your output doesn\'t contain neither \&quot;{survived}\&quot;'&#10;                f' nor \&quot;{hanged}\&quot;. You should output one of them.'&#10;            )&#10;&#10;        if is_hanged:&#10;            if wrong_count != 8:&#10;                return wrong(&#10;                    f'User was hanged after {wrong_count} wrong guesses, but should after 8'&#10;                )&#10;            else:&#10;                return accept()&#10;&#10;        if is_survived:&#10;            if wrong_count &gt;= 8:&#10;                return wrong(&#10;                    f'User survived but have {wrong_count} wrong guesses. He should be hanged'&#10;                )&#10;            else:&#10;                return accept()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hangman/hangman.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hangman/hangman.py" />
                                <option name="text" value="import random&#10;&#10;&#10;class Hangman:&#10;    __possible_words = {'python', 'java', 'kotlin', 'javascript'}&#10;    __attempts = 8&#10;&#10;    def __init__(self):&#10;        self.guessed_word = random.choice(tuple(self.__possible_words)).lower()&#10;        self.current_result = &quot;-&quot; * len(self.guessed_word)&#10;        self.guessed_letters = set(self.guessed_word)&#10;&#10;    def test2(self):&#10;        count = 0&#10;        while count &lt; Hangman.__attempts:&#10;            char = &quot;&quot;&#10;            while len(char) != 1:&#10;                print(self.current_result)&#10;                print()&#10;                char = input(&quot;Input a letter:  &quot;).lower()&#10;&#10;            if char in self.guessed_letters:&#10;                for i in range(len(self.guessed_word)):&#10;                    if self.guessed_word[i] == char:&#10;                        self.current_result = \&#10;                            self.current_result[:i] + char + self.current_result[i+1:]&#10;&#10;            else:&#10;                print(&quot;No such letter in the word&quot;)&#10;                count += 1&#10;            print()&#10;&#10;            if self.current_result == self.guessed_word:&#10;                break&#10;        print(&quot;Thanks for playing!\n&quot;&#10;              &quot;We'll see how well you did in the next stage&quot;, end=&quot;&quot;)&#10;&#10;&#10;if __name__ == '__main__':&#10;    print(&quot;H A N G M A N&quot;)&#10;    print()&#10;    game = Hangman()&#10;    game.test2()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561122738000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Calculate score and add fancy graphics&lt;/h2&gt;&#10;&#10;&lt;p&gt;We're almost done!&lt;/p&gt;&#10;&#10;&lt;p&gt;Let's add more flavor to the game by adding a suggestion to replay after the current game session ends.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Inputs and outputs&lt;/h2&gt;&#10;&#10;&lt;p&gt;The game starts with a menu where a player can choose to either play or exit.&lt;/p&gt;&#10;&#10;&lt;p&gt;Print &lt;code&gt;Type &quot;play&quot; to play the game, &quot;exit&quot; to quit:&lt;/code&gt; and ask again if the player inputs something else.&lt;/p&gt;&#10;&#10;&lt;p&gt;If the user chooses to play, the game starts.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Type &quot;play&quot; to play the game, &quot;exit&quot; to quit: play&#10;&#10;----------&#10;Input a letter: a&#10;&#10;-a-a------&#10;Input a letter: i&#10;&#10;-a-a---i--&#10;Input a letter: o&#10;No such letter in the word&#10;&#10;-a-a---i--&#10;Input a letter: o&#10;You already typed this letter&#10;&#10;-a-a---i--&#10;Input a letter: p&#10;&#10;-a-a---ip-&#10;Input a letter: p&#10;You already typed this letter&#10;&#10;-a-a---ip-&#10;Input a letter: h&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: k&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: a&#10;You already typed this letter&#10;&#10;-a-a---ip-&#10;Input a letter: z&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: t&#10;&#10;-a-a---ipt&#10;Input a letter: x&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: b&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: d&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: w&#10;No such letter in the word&#10;You are hanged!&#10;&#10;Type &quot;play&quot; to play the game, &quot;exit&quot; to quit: exit&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/379/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6089" />
                      <option name="index" value="8" />
                      <option name="name" value="Menu, please" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import accept, wrong&#10;&#10;from random import shuffle, randint&#10;from string import ascii_lowercase, ascii_letters, punctuation, digits&#10;&#10;&#10;description_list = ['python', 'java', 'kotlin', 'javascript']&#10;out_of_description = ['clojure', 'haskell', 'typescript', 'assembler']&#10;&#10;catch = {i: 0 for i in description_list}&#10;all_letters = ascii_letters + punctuation + digits&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests = []&#10;&#10;        for word in description_list + out_of_description + [ascii_lowercase]:&#10;            for i in range(100):&#10;                words = [w if randint(1, 100) &lt; 95 else w + w for w in word * 50 + all_letters]&#10;                shuffle(words)&#10;                inputs = '\n'.join(words)&#10;                inputs = 'play\n' + inputs + '\nexit'&#10;                tests += [TestCase(stdin=inputs, attach=words)]&#10;&#10;        shuffle(tests)&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;&#10;        tries = [i.strip() for i in reply.split('\n\n') if len(i.strip())][1:]&#10;&#10;        if len(tries) == 0:&#10;            return wrong(&#10;                &quot;Seems like you didn't print the game or not separated output properly&quot;&#10;                &quot;(there need to be an empty line between guessing attempts)&quot;&#10;            )&#10;&#10;        full_blocks = [try_ for try_ in tries if len(try_.splitlines()) &gt; 1]&#10;        blocks = [block.splitlines()[0].strip() for block in full_blocks]&#10;&#10;        for full_block, block in zip(full_blocks, blocks):&#10;            if ' ' in block:&#10;                return wrong(&#10;                    'Cannot parse this block - it contains spaces '&#10;                    'in the first line, but shouldn\'t\n\n'&#10;                    f'{full_block}'&#10;                )&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        is_survived = survived in full_blocks[-1]&#10;        is_hanged = hanged in full_blocks[-1]&#10;&#10;        no_such_letter = 'No such letter in the word'&#10;        already_typed = 'You already typed this letter'&#10;        not_ascii = 'It is not an ASCII lowercase letter'&#10;        print_single = 'You should print a single letter'&#10;&#10;        lengths = set(len(i) for i in blocks)&#10;&#10;        str_lengths = []&#10;        for i, curr_len in enumerate(lengths, 1):&#10;            for curr_block in blocks:&#10;                if curr_len == len(curr_block):&#10;                    str_lengths += [f'{i}. {curr_block}']&#10;                    break&#10;&#10;        str_lengths = '\n'.join(str_lengths)&#10;&#10;        if len(lengths) &gt; 1:&#10;            return wrong(&#10;                f'Every line with guessed letters should be the same length as others.\n'&#10;                f'Found lines with guessed letters:\n{str_lengths}'&#10;            )&#10;&#10;        correct = '-'*len(blocks[0])&#10;&#10;        if blocks[0] != correct:&#10;            return wrong(&#10;                f'The first guess should only contain dashes: \n'&#10;                f'{correct}\n'&#10;                f'Your first guess:\n'&#10;                f'{blocks[0]}'&#10;            )&#10;&#10;        wrong_count = 0&#10;        typed_letters = set()&#10;        inputs = ''&#10;&#10;        if is_hanged:&#10;            blocks += [blocks[-1]]&#10;            full_blocks += [full_blocks[-1]]&#10;&#10;        for letter, prev, next, prev_full, next_full in zip(&#10;                attach, blocks[0:], blocks[1:], full_blocks[0:], full_blocks[1:]):&#10;&#10;            # ---&#10;            detect_not_one = len(letter) != 1&#10;&#10;            if detect_not_one and print_single not in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{print_single}\&quot; message, but should be'&#10;                )&#10;            elif not detect_not_one and print_single in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{print_single}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            if detect_not_one:&#10;                continue&#10;&#10;            # ---&#10;            detect_not_ascii = letter not in ascii_lowercase&#10;&#10;            if detect_not_ascii and not_ascii not in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{not_ascii}\&quot; message, but should be'&#10;                )&#10;            elif not detect_not_ascii and not_ascii in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{not_ascii}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            if detect_not_ascii:&#10;                continue&#10;&#10;            inputs += '\n' + letter&#10;&#10;            # ---&#10;            detect_typed_letter = letter in typed_letters&#10;&#10;            if detect_typed_letter and already_typed not in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{already_typed}\&quot; message, but should be\n'&#10;                    f'Input letters: {inputs}'&#10;                )&#10;            elif not detect_typed_letter and already_typed in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{already_typed}\&quot; message, but shouldn\'t be'&#10;                    f'Input letters: {inputs}'&#10;                )&#10;&#10;            if detect_typed_letter:&#10;                continue&#10;&#10;            # ---&#10;            detect_no_such_letter = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next == prev) and not detect_typed_letter&#10;            )&#10;&#10;            if detect_no_such_letter and no_such_letter not in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{no_such_letter}\&quot; message, but should be'&#10;                )&#10;            elif not detect_no_such_letter and no_such_letter in prev_full:&#10;                return wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{no_such_letter}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            if detect_no_such_letter:&#10;                wrong_count += 1&#10;&#10;            typed_letters |= {letter}&#10;&#10;            cond1 = (&#10;                (letter not in prev) and&#10;                (letter in next) and&#10;                (set(next) - set(prev) != set(letter))&#10;            )&#10;&#10;            cond2 = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            cond3 = (&#10;                (letter in prev) and&#10;                (letter in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            if cond1 or cond2 or cond3:&#10;                return wrong(&#10;                    f'This transition is incorrect:\n'&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}'&#10;                )&#10;&#10;        if is_survived and is_hanged:&#10;            return wrong(&#10;                f'Looks like your output contains both \&quot;{survived}\&quot;'&#10;                f' and \&quot;{hanged}\&quot;. You should output only one of them.'&#10;            )&#10;&#10;        if not is_survived and not is_hanged:&#10;            return wrong(&#10;                f'Looks like your output doesn\'t contain neither \&quot;{survived}\&quot;'&#10;                f' nor \&quot;{hanged}\&quot;. You should output one of them.'&#10;            )&#10;&#10;        if is_hanged:&#10;            if wrong_count != 8:&#10;                return wrong(&#10;                    f'User was hanged after {wrong_count} wrong guesses, but should after 8'&#10;                )&#10;            else:&#10;                return accept()&#10;&#10;        if is_survived:&#10;            if wrong_count &gt;= 8:&#10;                return wrong(&#10;                    f'User survived but have {wrong_count} wrong guesses. He should be hanged'&#10;                )&#10;            else:&#10;                return accept()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hangman/hangman.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hangman/hangman.py" />
                                <option name="text" value="import random&#10;&#10;&#10;class Hangman:&#10;    __possible_words = {'python', 'java', 'kotlin', 'javascript'}&#10;    __attempts = 8&#10;&#10;    def __init__(self):&#10;        self.guessed_word = random.choice(tuple(self.__possible_words)).lower()&#10;        self.current_result = &quot;-&quot; * len(self.guessed_word)&#10;        self.guessed_letters = set(self.guessed_word)&#10;&#10;    def test2(self):&#10;        count = 0&#10;        while count &lt; Hangman.__attempts:&#10;            char = &quot;&quot;&#10;            while len(char) != 1:&#10;                print(self.current_result)&#10;                print()&#10;                char = input(&quot;Input a letter:  &quot;).lower()&#10;&#10;            if char in self.guessed_letters:&#10;                for i in range(len(self.guessed_word)):&#10;                    if self.guessed_word[i] == char:&#10;                        self.current_result = \&#10;                            self.current_result[:i] + char + self.current_result[i+1:]&#10;&#10;            else:&#10;                print(&quot;No such letter in the word&quot;)&#10;                count += 1&#10;            print()&#10;&#10;            if self.current_result == self.guessed_word:&#10;                break&#10;        print(&quot;Thanks for playing!\n&quot;&#10;              &quot;We'll see how well you did in the next stage&quot;, end=&quot;&quot;)&#10;&#10;&#10;if __name__ == '__main__':&#10;    print(&quot;H A N G M A N&quot;)&#10;    print()&#10;    game = Hangman()&#10;    game.test2()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561122739000" />
                    </EduTask>
                  </list>
                </option>
              </FrameworkLesson>
            </list>
          </option>
        </HyperskillCourse>
      </option>
    </StudyTaskManager>
  </component>
</project>