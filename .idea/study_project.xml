<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="StudySettings">
    <StudyTaskManager>
      <option name="VERSION" value="14" />
      <option name="myUserTests">
        <map />
      </option>
      <option name="course">
        <HyperskillCourse>
          <option name="authors">
            <list />
          </option>
          <option name="courseMode" value="Study" />
          <option name="customPresentableName" />
          <option name="description" value="A famous game with a 3x3 field. You can build a simple AI and play against it. You’ll learn to create bots of various types of difficulty.&lt;br/&gt;&lt;br/&gt;Learn more at &lt;a href=&quot;https://hyperskill.org&quot;&gt;https://hyperskill.org/projects/73&lt;/a&gt;" />
          <option name="environment" value="" />
          <option name="fromZip" value="false" />
          <option name="id" value="0" />
          <option name="index" value="-1" />
          <option name="language" value="Python" />
          <option name="languageCode" value="en" />
          <option name="name" value="Tic-Tac-Toe with AI in Python" />
          <option name="stages">
            <list>
              <HyperskillStage>
                <option name="id" value="399" />
                <option name="stepId" value="6503" />
                <option name="title" value="Print a state of the game field" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="400" />
                <option name="stepId" value="6504" />
                <option name="title" value="Create a simple game field" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="401" />
                <option name="stepId" value="6505" />
                <option name="title" value="Print the game state" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="402" />
                <option name="stepId" value="6506" />
                <option name="title" value="Create a human move" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="403" />
                <option name="stepId" value="6507" />
                <option name="title" value="Find errors in user input" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="404" />
                <option name="stepId" value="6508" />
                <option name="title" value="Make an &quot;easy&quot; difficulty level" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="405" />
                <option name="stepId" value="6509" />
                <option name="title" value="Create a game loop" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="406" />
                <option name="stepId" value="6510" />
                <option name="title" value="Create a start menu" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="407" />
                <option name="stepId" value="6511" />
                <option name="title" value="Make a &quot;medium&quot; difficulty level" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="408" />
                <option name="stepId" value="6512" />
                <option name="title" value="Make a &quot;hard&quot; difficulty level" />
              </HyperskillStage>
            </list>
          </option>
          <option name="stepikChangeStatus" value="Up to date" />
          <option name="taskToTopics">
            <map />
          </option>
          <option name="updateDate" value="0" />
          <option name="hyperskillProject">
            <HyperskillProject>
              <option name="description" value="A famous game with a 3x3 field. You can build a simple AI and play against it. You’ll learn to create bots of various types of difficulty." />
              <option name="id" value="73" />
              <option name="ideFiles" value="https://stepik.org/media/attachments/lesson/239550/additional_files.json" />
              <option name="language" value="python" />
              <option name="title" value="Tic-Tac-Toe with AI in Python" />
              <option name="useIde" value="true" />
            </HyperskillProject>
          </option>
          <option name="items">
            <list>
              <FrameworkLesson>
                <option name="currentTaskIndex" value="0" />
                <option name="customPresentableName" />
                <option name="id" value="0" />
                <option name="index" value="1" />
                <option name="name" value="Tic-Tac-Toe with AI in Python" />
                <option name="stepikChangeStatus" value="Up to date" />
                <option name="updateDate" value="0" />
                <option name="unitId" value="0" />
                <option name="items">
                  <list>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Tic-tac-toe is a game played by two players on a 3x3 field.&lt;/p&gt;&#10;&#10;&lt;p&gt;One of the players plays as 'X', and the other player is 'O'. 'X' plays first, then the 'O' side plays, and so on.&lt;/p&gt;&#10;&#10;&lt;p&gt;The players write 'X' and 'O' on a 3x3 field.&lt;/p&gt;&#10;&#10;&lt;p&gt;The first player that writes 3 'X' or 3 'O' in a straight line (including diagonals) wins.&lt;br&gt;&#10;&lt;br&gt;&#10;Your first task in this project is to print any state of the field in the console output.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;The example below shows how your output might look.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;X O X&#10;O X O&#10;X X O &lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/73/stages/399/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6503" />
                      <option name="index" value="1" />
                      <option name="name" value="Print a state of the game field" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;import re&#10;&#10;&#10;class TicTacToeTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        return [TestCase()]&#10;&#10;    def check(self, reply: str, attach: str) -&gt; CheckResult:&#10;        reply = re.sub(&quot;\\s+&quot;, &quot;&quot;, reply)&#10;        if len(reply) &gt; 9:&#10;            return CheckResult(False, &quot;You need to output no more than 9 symbols&quot;)&#10;        have_x = False&#10;        have_o = False&#10;        for c in reply:&#10;            if c != 'X' and c != 'O':&#10;                return CheckResult(False, &quot;You need to output X and O &quot; + &quot;symbols only not counting spaces&quot;)&#10;            if c == 'X':&#10;                have_x = True&#10;            if c == 'O':&#10;                have_o = True&#10;        if not have_x:&#10;            return CheckResult.false(&quot;You need to output at least one X&quot;)&#10;        if not have_o:&#10;            return CheckResult.false(&quot;You need to output at least one O&quot;)&#10;        return CheckResult.true()&#10;&#10;&#10;if __name__ == '__main__':&#10;    TicTacToeTest('tictactoe.tictactoe').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any, Dict&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    @staticmethod&#10;    def create_files(files: Dict[str, str]):&#10;        for file, content in files.items():&#10;            with open(file, 'w') as f:&#10;                f.write(content)&#10;&#10;    @staticmethod&#10;    def delete_files(files: Dict[str, str]):&#10;        for file in files.keys():&#10;            if os.path.isfile(file):&#10;                os.remove(file)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            self.create_files(test_case.files)&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            self.delete_files(test_case.files)&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tictactoe/tictactoe.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tictactoe/tictactoe.py" />
                                <option name="text" value="# write your code here&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561463813000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;In this stage, you should write a program that reads 11 symbols (notice that input includes &lt;code&gt;&quot;&lt;/code&gt; symbols at the start and in the end of a line) from the input and writes an appropriate 3x3 field. Elements of the field can contain only &lt;code&gt;'X'&lt;/code&gt;, &lt;code&gt;'O'&lt;/code&gt; and &lt;code&gt;' '&lt;/code&gt; symbols (and input contain only these symbols except &lt;code&gt;&quot;&lt;/code&gt; at the start and in the end).&lt;/p&gt;&#10;&#10;&lt;p&gt;Note, that field has a specific format and should start and end with &lt;code&gt;'---------'&lt;/code&gt;, all lines in between should start and end with &lt;code&gt;'|'&lt;/code&gt; symbol and cells and &lt;code&gt;'|'&lt;/code&gt; symbols should be separated with a single space.  &lt;br&gt;&#10; &lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;Examples below show how your output should look.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot;O OXXO XX&quot;&#10;---------&#10;| O   O |&#10;| X X O |&#10;|   X X |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot;OXO  X OX&quot;&#10;---------&#10;| O X O |&#10;|     X |&#10;|   O X |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot; XO  X   &quot;&#10;---------&#10;|   X O |&#10;|     X |&#10;|       |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/73/stages/400/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6504" />
                      <option name="index" value="2" />
                      <option name="name" value="Create a simple game field" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from enum import Enum&#10;from typing import List, Optional&#10;from copy import deepcopy&#10;&#10;&#10;class FieldState(Enum):&#10;    X = 'X'&#10;    O = 'O'&#10;    FREE = ' '&#10;&#10;&#10;def get_state(symbol):&#10;    if symbol == 'X':&#10;        return FieldState.X&#10;    elif symbol == 'O':&#10;        return FieldState.O&#10;    elif symbol == ' ':&#10;        return FieldState.FREE&#10;    else:&#10;        return None&#10;&#10;&#10;class TicTacToeField:&#10;&#10;    def __init__(self, *, field: str = '', constructed=None):&#10;&#10;        if constructed is not None:&#10;            self.field = deepcopy(constructed)&#10;&#10;        else:&#10;            self.field: List[List[Optional[FieldState]]] = [&#10;                [None for _ in range(3)] for _ in range(3)&#10;            ]&#10;&#10;            field = field.replace(&quot;\&quot;&quot;, &quot;&quot;)&#10;&#10;            for row in range(3):&#10;                for col in range(3):&#10;                    index = (2 - row) * 3 + col&#10;                    self.field[row][col] = get_state(field[index])&#10;&#10;    def equal_to(self, other) -&gt; bool:&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    return False&#10;        return True&#10;&#10;    def has_next_as(self, other) -&gt; bool:&#10;        improved: bool = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if self.field[i][j] == FieldState.FREE and not improved:&#10;                        improved = True&#10;                    else:&#10;                        return False&#10;        return improved&#10;&#10;    def differ_by_one(self, other) -&gt; bool:&#10;        have_single_difference = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if have_single_difference:&#10;                        return False&#10;                    have_single_difference = True&#10;        return have_single_difference&#10;&#10;    def is_close_to(self, other) -&gt; bool:&#10;        return (&#10;            self.equal_to(other)&#10;            or self.has_next_as(other)&#10;            or other.has_next_as(self)&#10;        )&#10;&#10;    @staticmethod&#10;    def parse(field_str: str):&#10;&#10;        lines = field_str.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if&#10;                 i.startswith('|') and i.endswith('|')]&#10;&#10;        for line in lines:&#10;            for c in line:&#10;                if c not in 'XO| ':&#10;                    return None&#10;&#10;        field: List[List[Optional[FieldState]]] = [&#10;            [None for _ in range(3)] for _ in range(3)&#10;        ]&#10;&#10;        y: int = 2&#10;&#10;        for line in lines:&#10;            cols = line[2], line[4], line[6]&#10;            x: int = 0&#10;            for c in cols:&#10;                state = get_state(c)&#10;                if state is None:&#10;                    return None&#10;                field[y][x] = state&#10;                x += 1&#10;            y -= 1&#10;&#10;        return TicTacToeField(constructed=field)&#10;&#10;    @staticmethod&#10;    def parse_all(output: str):&#10;        fields = []&#10;&#10;        lines = output.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if len(i) &gt; 0]&#10;&#10;        candidate_field = ''&#10;        inside_field = False&#10;        for line in lines:&#10;            if '----' in line and not inside_field:&#10;                inside_field = True&#10;                candidate_field = ''&#10;            elif '----' in line and inside_field:&#10;                field = TicTacToeField.parse(candidate_field)&#10;                if field is not None:&#10;                    fields += [field]&#10;                inside_field = False&#10;&#10;            if inside_field and line.startswith('|'):&#10;                candidate_field += line + '\n'&#10;&#10;        return fields&#10;&#10;&#10;class TicTacToeTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests: List[TestCase] = [&#10;            TestCase(stdin=&quot;O OXXO XX&quot;),&#10;            TestCase(stdin=&quot;OXO  X OX&quot;),&#10;            TestCase(stdin=&quot;         &quot;),&#10;            TestCase(stdin=&quot; O  X   X&quot;)&#10;        ]&#10;        for test in tests:&#10;            test.input = &quot;\&quot;&quot; + test.input + &quot;\&quot;&quot;&#10;            test.attach = test.input&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: str) -&gt; CheckResult:&#10;        fields = TicTacToeField.parse_all(reply)&#10;        if len(fields) == 0:&#10;            return CheckResult.false(&#10;                &quot;Can't parse the field! &quot;&#10;                &quot;Check if you output a field &quot;&#10;                &quot;in format like in the example.&quot;&#10;            )&#10;&#10;        if len(fields) &gt; 1:&#10;            return CheckResult.false(&#10;                &quot;There are more than one field in the output! &quot;&#10;                &quot;You should output a single field.&quot;&#10;            )&#10;&#10;        user_field = fields[0]&#10;        input_field = TicTacToeField(field=attach)&#10;        if not user_field.equal_to(input_field):&#10;            return CheckResult.false(&#10;                &quot;Your field doesn't match expected field&quot;&#10;            )&#10;        return CheckResult.true()&#10;&#10;&#10;if __name__ == '__main__':&#10;    TicTacToeTest('tictactoe.tictactoe').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any, Dict&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    @staticmethod&#10;    def create_files(files: Dict[str, str]):&#10;        for file, content in files.items():&#10;            with open(file, 'w') as f:&#10;                f.write(content)&#10;&#10;    @staticmethod&#10;    def delete_files(files: Dict[str, str]):&#10;        for file in files.keys():&#10;            if os.path.isfile(file):&#10;                os.remove(file)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            self.create_files(test_case.files)&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            self.delete_files(test_case.files)&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tictactoe/tictactoe.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tictactoe/tictactoe.py" />
                                <option name="text" value="# write your code here&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561463814000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;In this stage, you should analyze a Tic-Tac-Toe field. &lt;/p&gt;&#10;&#10;&lt;p&gt;After printing the field, you need to find the state in which the game is at the moment. Possible states:&lt;/p&gt;&#10;&#10;&lt;ul&gt;&#10;&#9;&lt;li&gt;&lt;code&gt;&quot;Game not finished&quot;&lt;/code&gt; - when no side has a three in a row but the field has empty cells;&lt;/li&gt;&#10;&#9;&lt;li&gt;&lt;code&gt;&quot;Draw&quot;&lt;/code&gt; - when no side has a three in a row and the field has no empty cells;&lt;/li&gt;&#10;&#9;&lt;li&gt;&lt;code&gt;&quot;X wins&quot;&lt;/code&gt; - when the field has three X in a row;&lt;/li&gt;&#10;&#9;&lt;li&gt;&lt;code&gt;&quot;O wins&quot;&lt;/code&gt; - when the field has three O in a row;&lt;/li&gt;&#10;&#9;&lt;li&gt;&lt;code&gt;&quot;Impossible&quot;&lt;/code&gt; - when the field has three X in a row as well as three O in a row. Or the field has a lot more X's that O's or vice versa (if the difference is 2 or more, should be 1 or 0).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;The examples below shows outputs for some predefined states. Your program should work in the same way.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot;XXXOO  O &quot;&#10;---------&#10;| X X X |&#10;| O O   |&#10;|   O   |&#10;---------&#10;X wins&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot;XOXOXOXXO&quot;&#10;---------&#10;| X O X |&#10;| O X O |&#10;| X X O |&#10;---------&#10;X wins&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot;XOOOXOXXO&quot;&#10;---------&#10;| X O O |&#10;| O X O |&#10;| X X O |&#10;---------&#10;O wins&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot;XOXOOXXXO&quot;&#10;---------&#10;| X O X |&#10;| O O X |&#10;| X X O |&#10;---------&#10;Draw&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot;XO OOX X &quot;&#10;---------&#10;| X O   |&#10;| O O X |&#10;|   X   |&#10;---------&#10;Game not finished&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot;XO XO XOX&quot;&#10;---------&#10;| X O   |&#10;| X O   |&#10;| X O X |&#10;---------&#10;Impossible&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot; O X  X X&quot;&#10;---------&#10;|   O   |&#10;| X     |&#10;| X   X |&#10;---------&#10;Impossible&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot; OOOO X X&quot;&#10;---------&#10;|   O O |&#10;| O O   |&#10;| X   X |&#10;---------&#10;Impossible&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/73/stages/401/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6505" />
                      <option name="index" value="3" />
                      <option name="name" value="Print the game state" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from enum import Enum&#10;from typing import List, Optional&#10;from copy import deepcopy&#10;&#10;&#10;class FieldState(Enum):&#10;    X = 'X'&#10;    O = 'O'&#10;    FREE = ' '&#10;&#10;&#10;def get_state(symbol):&#10;    if symbol == 'X':&#10;        return FieldState.X&#10;    elif symbol == 'O':&#10;        return FieldState.O&#10;    elif symbol == ' ':&#10;        return FieldState.FREE&#10;    else:&#10;        return None&#10;&#10;&#10;class TicTacToeField:&#10;&#10;    def __init__(self, *, field: str = '', constructed=None):&#10;&#10;        if constructed is not None:&#10;            self.field = deepcopy(constructed)&#10;&#10;        else:&#10;            self.field: List[List[Optional[FieldState]]] = [&#10;                [None for _ in range(3)] for _ in range(3)&#10;            ]&#10;&#10;            field = field.replace(&quot;\&quot;&quot;, &quot;&quot;)&#10;&#10;            for row in range(3):&#10;                for col in range(3):&#10;                    index = (2 - row) * 3 + col&#10;                    self.field[row][col] = get_state(field[index])&#10;&#10;    def equal_to(self, other) -&gt; bool:&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    return False&#10;        return True&#10;&#10;    def has_next_as(self, other) -&gt; bool:&#10;        improved: bool = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if self.field[i][j] == FieldState.FREE and not improved:&#10;                        improved = True&#10;                    else:&#10;                        return False&#10;        return improved&#10;&#10;    def differ_by_one(self, other) -&gt; bool:&#10;        have_single_difference = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if have_single_difference:&#10;                        return False&#10;                    have_single_difference = True&#10;        return have_single_difference&#10;&#10;    def is_close_to(self, other) -&gt; bool:&#10;        return (&#10;            self.equal_to(other)&#10;            or self.has_next_as(other)&#10;            or other.has_next_as(self)&#10;        )&#10;&#10;    @staticmethod&#10;    def parse(field_str: str):&#10;&#10;        lines = field_str.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if&#10;                 i.startswith('|') and i.endswith('|')]&#10;&#10;        for line in lines:&#10;            for c in line:&#10;                if c not in 'XO| ':&#10;                    return None&#10;&#10;        field: List[List[Optional[FieldState]]] = [&#10;            [None for _ in range(3)] for _ in range(3)&#10;        ]&#10;&#10;        y: int = 2&#10;&#10;        for line in lines:&#10;            cols = line[2], line[4], line[6]&#10;            x: int = 0&#10;            for c in cols:&#10;                state = get_state(c)&#10;                if state is None:&#10;                    return None&#10;                field[y][x] = state&#10;                x += 1&#10;            y -= 1&#10;&#10;        return TicTacToeField(constructed=field)&#10;&#10;    @staticmethod&#10;    def parse_all(output: str):&#10;        fields = []&#10;&#10;        lines = output.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if len(i) &gt; 0]&#10;&#10;        candidate_field = ''&#10;        inside_field = False&#10;        for line in lines:&#10;            if '----' in line and not inside_field:&#10;                inside_field = True&#10;                candidate_field = ''&#10;            elif '----' in line and inside_field:&#10;                field = TicTacToeField.parse(candidate_field)&#10;                if field is not None:&#10;                    fields += [field]&#10;                inside_field = False&#10;&#10;            if inside_field and line.startswith('|'):&#10;                candidate_field += line + '\n'&#10;&#10;        return fields&#10;&#10;&#10;class TicTacToeTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests: List[TestCase] = [&#10;            TestCase(stdin=&quot;XXXOO  O &quot;, attach=&quot;X wins&quot;),&#10;            TestCase(stdin=&quot;XOXOXOXXO&quot;, attach=&quot;X wins&quot;),&#10;            TestCase(stdin=&quot;XOOOXOXXO&quot;, attach=&quot;O wins&quot;),&#10;            TestCase(stdin=&quot;XOXOOXXXO&quot;, attach=&quot;Draw&quot;),&#10;            TestCase(stdin=&quot;XO OOX X &quot;, attach=&quot;Game not finished&quot;),&#10;            TestCase(stdin=&quot;XO XO XOX&quot;, attach=&quot;Impossible&quot;),&#10;            TestCase(stdin=&quot; O X  X X&quot;, attach=&quot;Impossible&quot;),&#10;            TestCase(stdin=&quot; OOOO X X&quot;, attach=&quot;Impossible&quot;)&#10;        ]&#10;        for test in tests:&#10;            test.input = &quot;\&quot;&quot; + test.input + &quot;\&quot;&quot;&#10;            test.attach = test.input, test.attach&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: str) -&gt; CheckResult:&#10;&#10;        clue_input, clue_result = attach&#10;&#10;        fields = TicTacToeField.parse_all(reply)&#10;        if len(fields) == 0:&#10;            return CheckResult.false(&#10;                &quot;Can't parse the field! &quot;&#10;                &quot;Check if you output a field &quot;&#10;                &quot;in format like in the example.&quot;&#10;            )&#10;&#10;        if len(fields) &gt; 1:&#10;            return CheckResult.false(&#10;                &quot;There are more than one field in the output! &quot;&#10;                &quot;You should output a single field.&quot;&#10;            )&#10;&#10;        user_field = fields[0]&#10;        input_field = TicTacToeField(field=clue_input)&#10;&#10;        if not user_field.equal_to(input_field):&#10;            return CheckResult.false(&#10;                &quot;Your field doesn't match expected field&quot;&#10;            )&#10;&#10;        lines = reply.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if len(i) &gt; 0]&#10;&#10;        last_line = lines[-1]&#10;&#10;        outcomes = [&#10;            &quot;X wins&quot;,&#10;            &quot;O wins&quot;,&#10;            &quot;Draw&quot;,&#10;            &quot;Game not finished&quot;,&#10;            &quot;Impossible&quot;&#10;        ]&#10;&#10;        if last_line not in outcomes:&#10;            return CheckResult.false(&#10;                &quot;Can't parse result, &quot;&#10;                &quot;should be one of the outcomes mentioned in description. &quot;&#10;                &quot;\nYour last line: \&quot;&quot; + last_line + &quot;\&quot;&quot;&#10;            )&#10;&#10;        if last_line != clue_result:&#10;            return CheckResult.false(&#10;                &quot;The result is incorrect. &quot; +&#10;                &quot;\nShould be: \&quot;&quot; + clue_result + &quot;\&quot;, &quot; +&#10;                &quot;\nfound: \&quot;&quot; + last_line + &quot;\&quot;. &quot; +&#10;                &quot;\nCheck if your program works correctly &quot;&#10;                &quot;in test examples in description.&quot;&#10;            )&#10;&#10;        return CheckResult.true()&#10;&#10;&#10;if __name__ == '__main__':&#10;    TicTacToeTest('tictactoe.tictactoe').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any, Dict&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    @staticmethod&#10;    def create_files(files: Dict[str, str]):&#10;        for file, content in files.items():&#10;            with open(file, 'w') as f:&#10;                f.write(content)&#10;&#10;    @staticmethod&#10;    def delete_files(files: Dict[str, str]):&#10;        for file in files.keys():&#10;            if os.path.isfile(file):&#10;                os.remove(file)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            self.create_files(test_case.files)&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            self.delete_files(test_case.files)&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tictactoe/tictactoe.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tictactoe/tictactoe.py" />
                                <option name="text" value="# write your code here&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561463816000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Now you need to implement human moves.&lt;/p&gt;&#10;&#10;&lt;p&gt;Suppose the bottom left cell has the coordinates (1, 1) and the top right cell has the coordinates (3, 3).&lt;/p&gt;&#10;&#10;&lt;p&gt;The program should work in the following way:&lt;/p&gt;&#10;&#10;&lt;ol&gt;&#10;&#9;&lt;li&gt;Get the 3x3 field from the input as in the previous stages,&lt;/li&gt;&#10;&#9;&lt;li&gt;Output this 3x3 field with cells before the user's move,&lt;/li&gt;&#10;&#9;&lt;li&gt;Then ask the user about his next move,&lt;/li&gt;&#10;&#9;&lt;li&gt;Then the user should input 2 numbers that represent the cell on which user wants to make his X or O. (9 symbols representing the field would be on the first line and these 2 numbers would be on the second line of the user input),&lt;/li&gt;&#10;&#9;&lt;li&gt;Then output the table including the user's most recent move.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&#10;&lt;p&gt;Do not delete code that checks for table state; it will be useful in the future.&lt;/p&gt;&#10;&#10;&lt;p&gt;Note that in this stage user moves as X, not O. Keep in mind that the first coordinate goes from left to right and the second coodrinate goes from bottom to top. Also, notice that coordinates start with 1 and can be 1, 2 or 3.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;The examples below shows how your program should work.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot;X X O    &quot;&#10;---------&#10;| X   X |&#10;|   O   |&#10;|       |&#10;---------&#10;Enter the coordinates: 1 1&#10;---------&#10;| X   X |&#10;|   O   |&#10;| X     |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot; XXOO OX &quot;&#10;---------&#10;|   X X |&#10;| O O   |&#10;| O X   |&#10;---------&#10;Enter the coordinates: 1 3&#10;---------&#10;| X X X |&#10;| O O   |&#10;| O X   |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot; XXOO OX &quot;&#10;---------&#10;|   X X |&#10;| O O   |&#10;| O X   |&#10;---------&#10;Enter the coordinates: 3 1&#10;---------&#10;|   X X |&#10;| O O   |&#10;| O X X |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot; XXOO OX &quot;&#10;---------&#10;|   X X |&#10;| O O   |&#10;| O X   |&#10;---------&#10;Enter the coordinates: 3 2&#10;---------&#10;|   X X |&#10;| O O X |&#10;| O X   |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/73/stages/402/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6506" />
                      <option name="index" value="4" />
                      <option name="name" value="Create a human move" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from enum import Enum&#10;from typing import List, Optional&#10;from copy import deepcopy&#10;&#10;&#10;class FieldState(Enum):&#10;    X = 'X'&#10;    O = 'O'&#10;    FREE = ' '&#10;&#10;&#10;def get_state(symbol):&#10;    if symbol == 'X':&#10;        return FieldState.X&#10;    elif symbol == 'O':&#10;        return FieldState.O&#10;    elif symbol == ' ':&#10;        return FieldState.FREE&#10;    else:&#10;        return None&#10;&#10;&#10;class TicTacToeField:&#10;&#10;    def __init__(self, *, field: str = '', constructed=None):&#10;&#10;        if constructed is not None:&#10;            self.field = deepcopy(constructed)&#10;&#10;        else:&#10;            self.field: List[List[Optional[FieldState]]] = [&#10;                [None for _ in range(3)] for _ in range(3)&#10;            ]&#10;&#10;            field = field.replace(&quot;\&quot;&quot;, &quot;&quot;)&#10;&#10;            for row in range(3):&#10;                for col in range(3):&#10;                    index = (2 - row) * 3 + col&#10;                    self.field[row][col] = get_state(field[index])&#10;&#10;    def equal_to(self, other) -&gt; bool:&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    return False&#10;        return True&#10;&#10;    def has_next_as(self, other) -&gt; bool:&#10;        improved: bool = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if self.field[i][j] == FieldState.FREE and not improved:&#10;                        improved = True&#10;                    else:&#10;                        return False&#10;        return improved&#10;&#10;    def differ_by_one(self, other) -&gt; bool:&#10;        have_single_difference = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if have_single_difference:&#10;                        return False&#10;                    have_single_difference = True&#10;        return have_single_difference&#10;&#10;    def is_close_to(self, other) -&gt; bool:&#10;        return (&#10;            self.equal_to(other)&#10;            or self.has_next_as(other)&#10;            or other.has_next_as(self)&#10;        )&#10;&#10;    @staticmethod&#10;    def parse(field_str: str):&#10;&#10;        lines = field_str.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if&#10;                 i.startswith('|') and i.endswith('|')]&#10;&#10;        for line in lines:&#10;            for c in line:&#10;                if c not in 'XO| ':&#10;                    return None&#10;&#10;        field: List[List[Optional[FieldState]]] = [&#10;            [None for _ in range(3)] for _ in range(3)&#10;        ]&#10;&#10;        y: int = 2&#10;&#10;        for line in lines:&#10;            cols = line[2], line[4], line[6]&#10;            x: int = 0&#10;            for c in cols:&#10;                state = get_state(c)&#10;                if state is None:&#10;                    return None&#10;                field[y][x] = state&#10;                x += 1&#10;            y -= 1&#10;&#10;        return TicTacToeField(constructed=field)&#10;&#10;    @staticmethod&#10;    def parse_all(output: str):&#10;        fields = []&#10;&#10;        lines = output.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if len(i) &gt; 0]&#10;&#10;        candidate_field = ''&#10;        inside_field = False&#10;        for line in lines:&#10;            if '----' in line and not inside_field:&#10;                inside_field = True&#10;                candidate_field = ''&#10;            elif '----' in line and inside_field:&#10;                field = TicTacToeField.parse(candidate_field)&#10;                if field is not None:&#10;                    fields += [field]&#10;                inside_field = False&#10;&#10;            if inside_field and line.startswith('|'):&#10;                candidate_field += line + '\n'&#10;&#10;        return fields&#10;&#10;&#10;class TicTacToeTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests: List[TestCase] = [&#10;            TestCase(stdin=&quot;\&quot;X X O    \&quot;\n1 2&quot;,&#10;                     attach=(&quot;\&quot;X X O    \&quot;&quot;,&#10;                             &quot;\&quot;X XXO    \&quot;&quot;)),&#10;&#10;            TestCase(stdin=&quot;\&quot;X X O    \&quot;\n1 1&quot;,&#10;                     attach=(&quot;\&quot;X X O    \&quot;&quot;,&#10;                             &quot;\&quot;X X O X  \&quot;&quot;)),&#10;&#10;            TestCase(stdin=&quot;\&quot;X X O    \&quot;\n3 2&quot;,&#10;                     attach=(&quot;\&quot;X X O    \&quot;&quot;,&#10;                             &quot;\&quot;X X OX   \&quot;&quot;)),&#10;&#10;            TestCase(stdin=&quot;\&quot;X X O    \&quot;\n2 1&quot;,&#10;                     attach=(&quot;\&quot;X X O    \&quot;&quot;,&#10;                             &quot;\&quot;X X O  X \&quot;&quot;)),&#10;&#10;            TestCase(stdin=&quot;\&quot; XXOO OX \&quot;\n1 3&quot;,&#10;                     attach=(&quot;\&quot; XXOO OX \&quot;&quot;,&#10;                             &quot;\&quot;XXXOO OX \&quot;&quot;)),&#10;&#10;            TestCase(stdin=&quot;\&quot; XXOO OX \&quot;\n3 1&quot;,&#10;                     attach=(&quot;\&quot; XXOO OX \&quot;&quot;,&#10;                             &quot;\&quot; XXOO OXX\&quot;&quot;)),&#10;&#10;            TestCase(stdin=&quot;\&quot; XXOO OX \&quot;\n3 2&quot;,&#10;                     attach=(&quot;\&quot; XXOO OX \&quot;&quot;,&#10;                             &quot;\&quot; XXOOXOX \&quot;&quot;)),&#10;        ]&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: str) -&gt; CheckResult:&#10;&#10;        clue_input_field, clue_out_field = attach&#10;&#10;        fields = TicTacToeField.parse_all(reply)&#10;&#10;        if len(fields) != 2:&#10;            return CheckResult.false(&#10;                f&quot;You should output exactly 2 fields, found: {len(fields)}&quot;&#10;            )&#10;&#10;        curr: TicTacToeField = fields[0]&#10;        next: TicTacToeField = fields[1]&#10;&#10;        correct_curr = TicTacToeField(field=clue_input_field)&#10;        correct_next = TicTacToeField(field=clue_out_field)&#10;&#10;        if not curr.equal_to(correct_curr):&#10;            return CheckResult.false(&#10;                &quot;The first field is not equal to the input field&quot;&#10;            )&#10;&#10;        if not next.equal_to(correct_next):&#10;            return CheckResult.false(&#10;                &quot;The first field is correct, but the second is not&quot;&#10;            )&#10;&#10;        return CheckResult.true()&#10;&#10;&#10;if __name__ == '__main__':&#10;    TicTacToeTest('tictactoe.tictactoe').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any, Dict&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    @staticmethod&#10;    def create_files(files: Dict[str, str]):&#10;        for file, content in files.items():&#10;            with open(file, 'w') as f:&#10;                f.write(content)&#10;&#10;    @staticmethod&#10;    def delete_files(files: Dict[str, str]):&#10;        for file in files.keys():&#10;            if os.path.isfile(file):&#10;                os.remove(file)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            self.create_files(test_case.files)&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            self.delete_files(test_case.files)&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tictactoe/tictactoe.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tictactoe/tictactoe.py" />
                                <option name="text" value="# write your code here&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561463817000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;But what if the user enters incorrect coordinates? The user could enter symbols instead of numbers or enter coordinates representing occupied cells. You need to prevent all of that by checking a user's input and catching possible exceptions.&lt;/p&gt;&#10;&#10;&lt;p&gt;The program should do everything from the previous step but also check user input. If the user input is unsuitable, the program should ask him to enter coordinates again. &lt;/p&gt;&#10;&#10;&lt;p&gt;So, in this stage, you need to output a field from the first line of the input and then ask the user to enter a move. Keep asking until the user enters coordinate that represents an empty cell on the field and after that output the field with that move. You should output the field only 2 times - before the move and after a legal move.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;The examples below show how your program should work.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot; XXOO OX &quot;&#10;---------&#10;|   X X |&#10;| O O   |&#10;| O X   |&#10;---------&#10;Enter the coordinates: 1 1&#10;This cell is occupied! Choose another one!&#10;Enter the coordinates: 1 3&#10;---------&#10;| X X X |&#10;| O O   |&#10;| O X   |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot; XXOO OX &quot;&#10;---------&#10;|   X X |&#10;| O O   |&#10;| O X   |&#10;---------&#10;Enter the coordinates: one&#10;You should enter numbers!&#10;Enter the coordinates: one three&#10;You should enter numbers!&#10;Enter the coordinates: 1 3&#10;---------&#10;| X X X |&#10;| O O   |&#10;| O X   |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot; XXOO OX &quot;&#10;---------&#10;|   X X |&#10;| O O   |&#10;| O X   |&#10;---------&#10;Enter the coordinates: 4 1&#10;Coordinates should be from 1 to 3!&#10;Enter the coordinates: 1 4&#10;Coordinates should be from 1 to 3!&#10;Enter the coordinates: 1 3&#10;---------&#10;| X X X |&#10;| O O   |&#10;| O X   |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/73/stages/403/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6507" />
                      <option name="index" value="5" />
                      <option name="name" value="Find errors in user input" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from enum import Enum&#10;from typing import List, Optional&#10;from copy import deepcopy&#10;&#10;&#10;class FieldState(Enum):&#10;    X = 'X'&#10;    O = 'O'&#10;    FREE = ' '&#10;&#10;&#10;def get_state(symbol):&#10;    if symbol == 'X':&#10;        return FieldState.X&#10;    elif symbol == 'O':&#10;        return FieldState.O&#10;    elif symbol == ' ':&#10;        return FieldState.FREE&#10;    else:&#10;        return None&#10;&#10;&#10;class TicTacToeField:&#10;&#10;    def __init__(self, *, field: str = '', constructed=None):&#10;&#10;        if constructed is not None:&#10;            self.field = deepcopy(constructed)&#10;&#10;        else:&#10;            self.field: List[List[Optional[FieldState]]] = [&#10;                [None for _ in range(3)] for _ in range(3)&#10;            ]&#10;&#10;            field = field.replace(&quot;\&quot;&quot;, &quot;&quot;)&#10;&#10;            for row in range(3):&#10;                for col in range(3):&#10;                    index = (2 - row) * 3 + col&#10;                    self.field[row][col] = get_state(field[index])&#10;&#10;    def equal_to(self, other) -&gt; bool:&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    return False&#10;        return True&#10;&#10;    def has_next_as(self, other) -&gt; bool:&#10;        improved: bool = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if self.field[i][j] == FieldState.FREE and not improved:&#10;                        improved = True&#10;                    else:&#10;                        return False&#10;        return improved&#10;&#10;    def differ_by_one(self, other) -&gt; bool:&#10;        have_single_difference = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if have_single_difference:&#10;                        return False&#10;                    have_single_difference = True&#10;        return have_single_difference&#10;&#10;    def is_close_to(self, other) -&gt; bool:&#10;        return (&#10;            self.equal_to(other)&#10;            or self.has_next_as(other)&#10;            or other.has_next_as(self)&#10;        )&#10;&#10;    @staticmethod&#10;    def parse(field_str: str):&#10;&#10;        lines = field_str.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if&#10;                 i.startswith('|') and i.endswith('|')]&#10;&#10;        for line in lines:&#10;            for c in line:&#10;                if c not in 'XO| ':&#10;                    return None&#10;&#10;        field: List[List[Optional[FieldState]]] = [&#10;            [None for _ in range(3)] for _ in range(3)&#10;        ]&#10;&#10;        y: int = 2&#10;&#10;        for line in lines:&#10;            cols = line[2], line[4], line[6]&#10;            x: int = 0&#10;            for c in cols:&#10;                state = get_state(c)&#10;                if state is None:&#10;                    return None&#10;                field[y][x] = state&#10;                x += 1&#10;            y -= 1&#10;&#10;        return TicTacToeField(constructed=field)&#10;&#10;    @staticmethod&#10;    def parse_all(output: str):&#10;        fields = []&#10;&#10;        lines = output.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if len(i) &gt; 0]&#10;&#10;        candidate_field = ''&#10;        inside_field = False&#10;        for line in lines:&#10;            if '----' in line and not inside_field:&#10;                inside_field = True&#10;                candidate_field = ''&#10;            elif '----' in line and inside_field:&#10;                field = TicTacToeField.parse(candidate_field)&#10;                if field is not None:&#10;                    fields += [field]&#10;                inside_field = False&#10;&#10;            if inside_field and line.startswith('|'):&#10;                candidate_field += line + '\n'&#10;&#10;        return fields&#10;&#10;&#10;inputs = [&#10;    &quot;1 1&quot;, &quot;1 2&quot;, &quot;1 3&quot;,&#10;    &quot;2 1&quot;, &quot;2 2&quot;, &quot;2 3&quot;,&#10;    &quot;3 1&quot;, &quot;3 2&quot;, &quot;3 3&quot;&#10;]&#10;&#10;&#10;def iterate_cells(initial: str) -&gt; str:&#10;    index: int = -1&#10;    for i in range(len(inputs)):&#10;        if initial == inputs[i]:&#10;            index = i&#10;            break&#10;&#10;    if index == -1:&#10;        return ''&#10;&#10;    full_input: str = ''&#10;    for i in range(index, index + 9):&#10;        full_input += inputs[i % len(inputs)] + '\n'&#10;&#10;    return full_input&#10;&#10;&#10;class TicTacToeTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests: List[TestCase] = []&#10;&#10;        i: int = 0&#10;&#10;        start_fields = (&#10;            &quot;\&quot; XXOO OX \&quot;&quot;,&#10;            &quot;\&quot;         \&quot;&quot;,&#10;            &quot;\&quot;X X O    \&quot;&quot;&#10;        )&#10;&#10;        for start_field in start_fields:&#10;            for input in inputs:&#10;                full_input = iterate_cells(input)&#10;&#10;                str_nums = input.split()&#10;                x = int(str_nums[0])&#10;                y = int(str_nums[1])&#10;&#10;                if i % 2 == 1:&#10;                    full_input = f'4 {i}\n' + full_input&#10;&#10;                tests += [&#10;                    TestCase(&#10;                        stdin=start_field + '\n' + full_input,&#10;                        attach=(start_field, x, y)&#10;                    )&#10;                ]&#10;&#10;                i += 1&#10;&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: str) -&gt; CheckResult:&#10;&#10;        clue_input, clue_x, clue_y = attach&#10;&#10;        fields = TicTacToeField.parse_all(reply)&#10;&#10;        if len(fields) != 2:&#10;            return CheckResult.false(&#10;                f&quot;You should output exactly 2 fields, found: {len(fields)}&quot;&#10;            )&#10;&#10;        curr: TicTacToeField = fields[0]&#10;        next: TicTacToeField = fields[1]&#10;&#10;        correct_curr = TicTacToeField(field=clue_input)&#10;        correct_next = TicTacToeField(constructed=correct_curr.field)&#10;&#10;        num_inputs = iterate_cells(f'{clue_x} {clue_y}').split('\n')&#10;&#10;        for input in num_inputs:&#10;            str_nums = input.split()&#10;            x = int(str_nums[0])&#10;            y = int(str_nums[1])&#10;            if correct_next.field[y - 1][x - 1] == FieldState.FREE:&#10;                correct_next.field[y - 1][x - 1] = FieldState.X&#10;                break&#10;&#10;        if not curr.equal_to(correct_curr):&#10;            return CheckResult.false(&#10;                &quot;The first field is not equal to the input field&quot;&#10;            )&#10;&#10;        if not next.equal_to(correct_next):&#10;            return CheckResult.false(&#10;                &quot;The first field is correct, but the second is not&quot;&#10;            )&#10;&#10;        return CheckResult.true()&#10;&#10;&#10;if __name__ == '__main__':&#10;    TicTacToeTest('tictactoe.tictactoe').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any, Dict&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    @staticmethod&#10;    def create_files(files: Dict[str, str]):&#10;        for file, content in files.items():&#10;            with open(file, 'w') as f:&#10;                f.write(content)&#10;&#10;    @staticmethod&#10;    def delete_files(files: Dict[str, str]):&#10;        for file in files.keys():&#10;            if os.path.isfile(file):&#10;                os.remove(file)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            self.create_files(test_case.files)&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            self.delete_files(test_case.files)&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tictactoe/tictactoe.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tictactoe/tictactoe.py" />
                                <option name="text" value="# write your code here&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561463818000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Now let's program moves that a computer can make. In our game, there will be three different levels of difficulty.&lt;/p&gt;&#10;&#10;&lt;p&gt;In this step, you will program the &quot;easy&quot; level. This level just makes random moves. The program won't change much from the previous step. Just save the user's move logic somewhere (preferably in a separate method)—you will need it in the future—and implement the &quot;easy&quot; level move logic.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;The examples below shows how your program should work.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot;  XO  OX &quot;&#10;---------&#10;|     X |&#10;| O     |&#10;| O X   |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;|     X |&#10;| O     |&#10;| O X X |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot;  XO  OX &quot;&#10;---------&#10;|     X |&#10;| O     |&#10;| O X   |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;|   X X |&#10;| O     |&#10;| O X   |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Enter cells: &quot;  XO  OX &quot;&#10;---------&#10;|     X |&#10;| O     |&#10;| O X   |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;|     X |&#10;| O   X |&#10;| O X   |&#10;---------&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/73/stages/404/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6508" />
                      <option name="index" value="6" />
                      <option name="name" value="Make an &quot;easy&quot; difficulty level" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from enum import Enum&#10;from typing import List, Optional&#10;from copy import deepcopy&#10;&#10;&#10;class FieldState(Enum):&#10;    X = 'X'&#10;    O = 'O'&#10;    FREE = ' '&#10;&#10;&#10;def get_state(symbol):&#10;    if symbol == 'X':&#10;        return FieldState.X&#10;    elif symbol == 'O':&#10;        return FieldState.O&#10;    elif symbol == ' ':&#10;        return FieldState.FREE&#10;    else:&#10;        return None&#10;&#10;&#10;class TicTacToeField:&#10;&#10;    def __init__(self, *, field: str = '', constructed=None):&#10;&#10;        if constructed is not None:&#10;            self.field = deepcopy(constructed)&#10;&#10;        else:&#10;            self.field: List[List[Optional[FieldState]]] = [&#10;                [None for _ in range(3)] for _ in range(3)&#10;            ]&#10;&#10;            field = field.replace(&quot;\&quot;&quot;, &quot;&quot;)&#10;&#10;            for row in range(3):&#10;                for col in range(3):&#10;                    index = (2 - row) * 3 + col&#10;                    self.field[row][col] = get_state(field[index])&#10;&#10;    def equal_to(self, other) -&gt; bool:&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    return False&#10;        return True&#10;&#10;    def has_next_as(self, other) -&gt; bool:&#10;        improved: bool = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if self.field[i][j] == FieldState.FREE and not improved:&#10;                        improved = True&#10;                    else:&#10;                        return False&#10;        return improved&#10;&#10;    def differ_by_one(self, other) -&gt; bool:&#10;        have_single_difference = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if have_single_difference:&#10;                        return False&#10;                    have_single_difference = True&#10;        return have_single_difference&#10;&#10;    def is_close_to(self, other) -&gt; bool:&#10;        return (&#10;            self.equal_to(other)&#10;            or self.has_next_as(other)&#10;            or other.has_next_as(self)&#10;        )&#10;&#10;    @staticmethod&#10;    def parse(field_str: str):&#10;&#10;        lines = field_str.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if&#10;                 i.startswith('|') and i.endswith('|')]&#10;&#10;        for line in lines:&#10;            for c in line:&#10;                if c not in 'XO| ':&#10;                    return None&#10;&#10;        field: List[List[Optional[FieldState]]] = [&#10;            [None for _ in range(3)] for _ in range(3)&#10;        ]&#10;&#10;        y: int = 2&#10;&#10;        for line in lines:&#10;            cols = line[2], line[4], line[6]&#10;            x: int = 0&#10;            for c in cols:&#10;                state = get_state(c)&#10;                if state is None:&#10;                    return None&#10;                field[y][x] = state&#10;                x += 1&#10;            y -= 1&#10;&#10;        return TicTacToeField(constructed=field)&#10;&#10;    @staticmethod&#10;    def parse_all(output: str):&#10;        fields = []&#10;&#10;        lines = output.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if len(i) &gt; 0]&#10;&#10;        candidate_field = ''&#10;        inside_field = False&#10;        for line in lines:&#10;            if '----' in line and not inside_field:&#10;                inside_field = True&#10;                candidate_field = ''&#10;            elif '----' in line and inside_field:&#10;                field = TicTacToeField.parse(candidate_field)&#10;                if field is not None:&#10;                    fields += [field]&#10;                inside_field = False&#10;&#10;            if inside_field and line.startswith('|'):&#10;                candidate_field += line + '\n'&#10;&#10;        return fields&#10;&#10;&#10;inputs = [&#10;    &quot;1 1&quot;, &quot;1 2&quot;, &quot;1 3&quot;,&#10;    &quot;2 1&quot;, &quot;2 2&quot;, &quot;2 3&quot;,&#10;    &quot;3 1&quot;, &quot;3 2&quot;, &quot;3 3&quot;&#10;]&#10;&#10;&#10;def iterate_cells(initial: str) -&gt; str:&#10;    index: int = -1&#10;    for i in range(len(inputs)):&#10;        if initial == inputs[i]:&#10;            index = i&#10;            break&#10;&#10;    if index == -1:&#10;        return ''&#10;&#10;    full_input: str = ''&#10;    for i in range(index, index + 9):&#10;        full_input += inputs[i % len(inputs)] + '\n'&#10;&#10;    return full_input&#10;&#10;&#10;class TicTacToeTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests: List[TestCase] = [&#10;            TestCase(stdin=&quot;\&quot; XXOO OX \&quot;&quot;, attach=&quot;\&quot; XXOO OX \&quot;&quot;),&#10;            TestCase(stdin=&quot;\&quot;         \&quot;&quot;, attach=&quot;\&quot;         \&quot;&quot;),&#10;            TestCase(stdin=&quot;\&quot;X X O    \&quot;&quot;, attach=&quot;\&quot;X X O    \&quot;&quot;),&#10;        ]&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: str) -&gt; CheckResult:&#10;&#10;        fields = TicTacToeField.parse_all(reply)&#10;&#10;        if len(fields) != 2:&#10;            return CheckResult.false(&#10;                f&quot;You should output exactly 2 fields, found: {len(fields)}&quot;&#10;            )&#10;&#10;        if &quot;Making move level \&quot;easy\&quot;&quot; not in reply:&#10;            return CheckResult.false(&#10;                &quot;No \&quot;Making move level \&quot;easy\&quot;\&quot; line in output&quot;&#10;            )&#10;&#10;        curr: TicTacToeField = fields[0]&#10;        next: TicTacToeField = fields[1]&#10;&#10;        correct_curr = TicTacToeField(field=attach)&#10;&#10;        if not curr.equal_to(correct_curr):&#10;            return CheckResult.false(&#10;                &quot;The first field is not equal to the input field&quot;&#10;            )&#10;&#10;        if curr.equal_to(next):&#10;            return CheckResult.false(&#10;                &quot;The first field is equal to next, but should be different&quot;&#10;            )&#10;&#10;        if not curr.has_next_as(next):&#10;            return CheckResult.false(&#10;                &quot;The first field is correct, but the second is not&quot;&#10;            )&#10;&#10;        return CheckResult.true()&#10;&#10;&#10;if __name__ == '__main__':&#10;    TicTacToeTest('tictactoe.tictactoe').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any, Dict&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    @staticmethod&#10;    def create_files(files: Dict[str, str]):&#10;        for file, content in files.items():&#10;            with open(file, 'w') as f:&#10;                f.write(content)&#10;&#10;    @staticmethod&#10;    def delete_files(files: Dict[str, str]):&#10;        for file in files.keys():&#10;            if os.path.isfile(file):&#10;                os.remove(file)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            self.create_files(test_case.files)&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            self.delete_files(test_case.files)&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tictactoe/tictactoe.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tictactoe/tictactoe.py" />
                                <option name="text" value="# write your code here&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561463819000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Now it is time to make a working game. Keep in mind that you will write the other two levels of difficulty in the next steps. In this version of the program, the user will be playing X, and the easy level computer will be playing O.&lt;/p&gt;&#10;&#10;&lt;p&gt;You need to create a game loop. The game starts with empty cells and ends when someone wins or there is a draw. You need to output the final result after the end of the game.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;The example below shows how your program should work.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;---------&#10;|       |&#10;|       |&#10;|       |&#10;---------&#10;Enter the coordinates: 2 2&#10;---------&#10;|       |&#10;|   X   |&#10;|       |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;| O     |&#10;|   X   |&#10;|       |&#10;---------&#10;Enter the coordinates: 3 1&#10;---------&#10;| O     |&#10;|   X   |&#10;|     X |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;| O     |&#10;| O X   |&#10;|     X |&#10;---------&#10;Enter the coordinates: 1 1&#10;---------&#10;| O     |&#10;| O X   |&#10;| X   X |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;| O     |&#10;| O X O |&#10;| X   X |&#10;---------&#10;Enter the coordinates: 2 1&#10;---------&#10;| O     |&#10;| O X O |&#10;| X X X |&#10;---------&#10;X wins&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/73/stages/405/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6509" />
                      <option name="index" value="7" />
                      <option name="name" value="Create a game loop" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from enum import Enum&#10;from typing import List, Optional&#10;from copy import deepcopy&#10;&#10;&#10;class FieldState(Enum):&#10;    X = 'X'&#10;    O = 'O'&#10;    FREE = ' '&#10;&#10;&#10;def get_state(symbol):&#10;    if symbol == 'X':&#10;        return FieldState.X&#10;    elif symbol == 'O':&#10;        return FieldState.O&#10;    elif symbol == ' ':&#10;        return FieldState.FREE&#10;    else:&#10;        return None&#10;&#10;&#10;class TicTacToeField:&#10;&#10;    def __init__(self, *, field: str = '', constructed=None):&#10;&#10;        if constructed is not None:&#10;            self.field = deepcopy(constructed)&#10;&#10;        else:&#10;            self.field: List[List[Optional[FieldState]]] = [&#10;                [None for _ in range(3)] for _ in range(3)&#10;            ]&#10;&#10;            field = field.replace(&quot;\&quot;&quot;, &quot;&quot;)&#10;&#10;            for row in range(3):&#10;                for col in range(3):&#10;                    index = (2 - row) * 3 + col&#10;                    self.field[row][col] = get_state(field[index])&#10;&#10;    def equal_to(self, other) -&gt; bool:&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    return False&#10;        return True&#10;&#10;    def has_next_as(self, other) -&gt; bool:&#10;        improved: bool = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if self.field[i][j] == FieldState.FREE and not improved:&#10;                        improved = True&#10;                    else:&#10;                        return False&#10;        return improved&#10;&#10;    def differ_by_one(self, other) -&gt; bool:&#10;        have_single_difference = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if have_single_difference:&#10;                        return False&#10;                    have_single_difference = True&#10;        return have_single_difference&#10;&#10;    def is_close_to(self, other) -&gt; bool:&#10;        return (&#10;            self.equal_to(other)&#10;            or self.has_next_as(other)&#10;            or other.has_next_as(self)&#10;        )&#10;&#10;    @staticmethod&#10;    def parse(field_str: str):&#10;&#10;        lines = field_str.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if&#10;                 i.startswith('|') and i.endswith('|')]&#10;&#10;        for line in lines:&#10;            for c in line:&#10;                if c not in 'XO| ':&#10;                    return None&#10;&#10;        field: List[List[Optional[FieldState]]] = [&#10;            [None for _ in range(3)] for _ in range(3)&#10;        ]&#10;&#10;        y: int = 2&#10;&#10;        for line in lines:&#10;            cols = line[2], line[4], line[6]&#10;            x: int = 0&#10;            for c in cols:&#10;                state = get_state(c)&#10;                if state is None:&#10;                    return None&#10;                field[y][x] = state&#10;                x += 1&#10;            y -= 1&#10;&#10;        return TicTacToeField(constructed=field)&#10;&#10;    @staticmethod&#10;    def parse_all(output: str):&#10;        fields = []&#10;&#10;        lines = output.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if len(i) &gt; 0]&#10;&#10;        candidate_field = ''&#10;        inside_field = False&#10;        for line in lines:&#10;            if '----' in line and not inside_field:&#10;                inside_field = True&#10;                candidate_field = ''&#10;            elif '----' in line and inside_field:&#10;                field = TicTacToeField.parse(candidate_field)&#10;                if field is not None:&#10;                    fields += [field]&#10;                inside_field = False&#10;&#10;            if inside_field and line.startswith('|'):&#10;                candidate_field += line + '\n'&#10;&#10;        return fields&#10;&#10;&#10;inputs = [&#10;    &quot;1 1&quot;, &quot;1 2&quot;, &quot;1 3&quot;,&#10;    &quot;2 1&quot;, &quot;2 2&quot;, &quot;2 3&quot;,&#10;    &quot;3 1&quot;, &quot;3 2&quot;, &quot;3 3&quot;&#10;]&#10;&#10;&#10;def iterate_cells(initial: str) -&gt; str:&#10;    index: int = -1&#10;    for i in range(len(inputs)):&#10;        if initial == inputs[i]:&#10;            index = i&#10;            break&#10;&#10;    if index == -1:&#10;        return ''&#10;&#10;    full_input: str = ''&#10;    for i in range(index, index + 9):&#10;        full_input += inputs[i % len(inputs)] + '\n'&#10;&#10;    return full_input&#10;&#10;&#10;class TicTacToeTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests: List[TestCase] = []&#10;&#10;        i: int = 0&#10;        for input in inputs:&#10;            full_move_input = iterate_cells(input)&#10;&#10;            str_nums = input.split()&#10;            x = int(str_nums[0])&#10;            y = int(str_nums[1])&#10;&#10;            if i % 2 == 1:&#10;                full_move_input = f'4 {i}\n' + full_move_input&#10;&#10;            full_game_input = ''&#10;            for _ in range(9):&#10;                full_game_input += full_move_input&#10;&#10;            tests += [&#10;                TestCase(&#10;                    stdin=full_game_input,&#10;                    attach=(x, y)&#10;                )&#10;            ]&#10;&#10;            i += 1&#10;&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: str) -&gt; CheckResult:&#10;&#10;        clue_x, clue_y = attach&#10;&#10;        fields = TicTacToeField.parse_all(reply)&#10;&#10;        if len(fields) == 0:&#10;            return CheckResult.false(&#10;                &quot;No fields found&quot;&#10;            )&#10;&#10;        for i in range(1, len(fields)):&#10;            curr: TicTacToeField = fields[i - 1]&#10;            next: TicTacToeField = fields[i]&#10;&#10;            stayed = curr.equal_to(next)&#10;            improved = curr.has_next_as(next)&#10;&#10;            if not (stayed or improved):&#10;                return CheckResult.false(&#10;                    &quot;For two fields following each &quot; +&#10;                    &quot;other one is not a continuation &quot; +&#10;                    &quot;of the other.&quot;&#10;                )&#10;&#10;        if &quot;Making move level \&quot;easy\&quot;&quot; not in reply:&#10;            return CheckResult.false(&#10;                &quot;No \&quot;Making move level \&quot;easy\&quot;\&quot; line in output&quot;&#10;            )&#10;&#10;        return CheckResult.true()&#10;&#10;&#10;if __name__ == '__main__':&#10;    TicTacToeTest('tictactoe.tictactoe').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any, Dict&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    @staticmethod&#10;    def create_files(files: Dict[str, str]):&#10;        for file, content in files.items():&#10;            with open(file, 'w') as f:&#10;                f.write(content)&#10;&#10;    @staticmethod&#10;    def delete_files(files: Dict[str, str]):&#10;        for file in files.keys():&#10;            if os.path.isfile(file):&#10;                os.remove(file)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            self.create_files(test_case.files)&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            self.delete_files(test_case.files)&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tictactoe/tictactoe.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tictactoe/tictactoe.py" />
                                <option name="text" value="# write your code here&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561463821000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;It is time to make some variations of the game possible. What if you want to play with a friend and not with AI? What if you get tired of playing the game and want to see a match between two AI? Finally, you need to be able to play either the first move or the second move playing against AI.&lt;/p&gt;&#10;&#10;&lt;p&gt;Write a menu loop, which can interpret two commands: &quot;start&quot; and &quot;exit&quot;.&lt;/p&gt;&#10;&#10;&lt;p&gt;The command &quot;start&quot; should take two parameters: who will play ‘X’ and who will play ‘O.’ Two parameters are possible for now: &quot;user&quot; to play as a human and &quot;easy&quot; to play as an easy level AI. In the next steps, you will add &quot;medium&quot; and &quot;hard&quot; parameters.&lt;/p&gt;&#10;&#10;&lt;p&gt;The command &quot;exit&quot; should simply terminate the program.&lt;/p&gt;&#10;&#10;&lt;p&gt;Do not forget to handle incorrect input!&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;The example below shows how your program should work.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code&gt;Input command: start&#10;Bad parameters!&#10;Input command: start easy&#10;Bad parameters!&#10;Input command: start easy easy&#10;---------&#10;|       |&#10;|       |&#10;|       |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;|       |&#10;|     X |&#10;|       |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;|       |&#10;| O   X |&#10;|       |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;|       |&#10;| O   X |&#10;|     X |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;|       |&#10;| O   X |&#10;|   O X |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;|       |&#10;| O X X |&#10;|   O X |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;|     O |&#10;| O X X |&#10;|   O X |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;| X   O |&#10;| O X X |&#10;|   O X |&#10;---------&#10;X wins&#10;&#10;Input command: start easy user&#10;---------&#10;|       |&#10;|       |&#10;|       |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;|       |&#10;|       |&#10;|     X |&#10;---------&#10;Enter the coordinates: 2 2&#10;---------&#10;|       |&#10;|   O   |&#10;|     X |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;|   X   |&#10;|   O   |&#10;|     X |&#10;---------&#10;Enter the coordinates: 1 1&#10;---------&#10;|   X   |&#10;|   O   |&#10;| O   X |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;|   X X |&#10;|   O   |&#10;| O   X |&#10;---------&#10;Enter the coordinates: 3 2&#10;---------&#10;|   X X |&#10;|   O O |&#10;| O   X |&#10;---------&#10;Making move level &quot;easy&quot;&#10;---------&#10;| X X X |&#10;|   O O |&#10;| O   X |&#10;---------&#10;X wins&#10;&#10;Input command: start user user&#10;---------&#10;|       |&#10;|       |&#10;|       |&#10;---------&#10;Enter the coordinates: 1 1&#10;---------&#10;|       |&#10;|       |&#10;| X     |&#10;---------&#10;Enter the coordinates: 2 2&#10;---------&#10;|       |&#10;|   O   |&#10;| X     |&#10;---------&#10;Enter the coordinates: 1 2&#10;---------&#10;|       |&#10;| X O   |&#10;| X     |&#10;---------&#10;Enter the coordinates: 2 1&#10;---------&#10;|       |&#10;| X O   |&#10;| X O   |&#10;---------&#10;Enter the coordinates: 1 3&#10;---------&#10;| X     |&#10;| X O   |&#10;| X O   |&#10;---------&#10;X wins&#10;&#10;Input command: exit&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/73/stages/406/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6510" />
                      <option name="index" value="8" />
                      <option name="name" value="Create a start menu" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from enum import Enum&#10;from typing import List, Optional&#10;from copy import deepcopy&#10;&#10;&#10;class FieldState(Enum):&#10;    X = 'X'&#10;    O = 'O'&#10;    FREE = ' '&#10;&#10;&#10;def get_state(symbol):&#10;    if symbol == 'X':&#10;        return FieldState.X&#10;    elif symbol == 'O':&#10;        return FieldState.O&#10;    elif symbol == ' ':&#10;        return FieldState.FREE&#10;    else:&#10;        return None&#10;&#10;&#10;class TicTacToeField:&#10;&#10;    def __init__(self, *, field: str = '', constructed=None):&#10;&#10;        if constructed is not None:&#10;            self.field = deepcopy(constructed)&#10;&#10;        else:&#10;            self.field: List[List[Optional[FieldState]]] = [&#10;                [None for _ in range(3)] for _ in range(3)&#10;            ]&#10;&#10;            field = field.replace(&quot;\&quot;&quot;, &quot;&quot;)&#10;&#10;            for row in range(3):&#10;                for col in range(3):&#10;                    index = (2 - row) * 3 + col&#10;                    self.field[row][col] = get_state(field[index])&#10;&#10;    def equal_to(self, other) -&gt; bool:&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    return False&#10;        return True&#10;&#10;    def has_next_as(self, other) -&gt; bool:&#10;        improved: bool = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if self.field[i][j] == FieldState.FREE and not improved:&#10;                        improved = True&#10;                    else:&#10;                        return False&#10;        return improved&#10;&#10;    def differ_by_one(self, other) -&gt; bool:&#10;        have_single_difference = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if have_single_difference:&#10;                        return False&#10;                    have_single_difference = True&#10;        return have_single_difference&#10;&#10;    def is_close_to(self, other) -&gt; bool:&#10;        return (&#10;            self.equal_to(other)&#10;            or self.has_next_as(other)&#10;            or other.has_next_as(self)&#10;        )&#10;&#10;    @staticmethod&#10;    def parse(field_str: str):&#10;&#10;        lines = field_str.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if&#10;                 i.startswith('|') and i.endswith('|')]&#10;&#10;        for line in lines:&#10;            for c in line:&#10;                if c not in 'XO| ':&#10;                    return None&#10;&#10;        field: List[List[Optional[FieldState]]] = [&#10;            [None for _ in range(3)] for _ in range(3)&#10;        ]&#10;&#10;        y: int = 2&#10;&#10;        for line in lines:&#10;            cols = line[2], line[4], line[6]&#10;            x: int = 0&#10;            for c in cols:&#10;                state = get_state(c)&#10;                if state is None:&#10;                    return None&#10;                field[y][x] = state&#10;                x += 1&#10;            y -= 1&#10;&#10;        return TicTacToeField(constructed=field)&#10;&#10;    @staticmethod&#10;    def parse_all(output: str):&#10;        fields = []&#10;&#10;        lines = output.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if len(i) &gt; 0]&#10;&#10;        candidate_field = ''&#10;        inside_field = False&#10;        for line in lines:&#10;            if '----' in line and not inside_field:&#10;                inside_field = True&#10;                candidate_field = ''&#10;            elif '----' in line and inside_field:&#10;                field = TicTacToeField.parse(candidate_field)&#10;                if field is not None:&#10;                    fields += [field]&#10;                inside_field = False&#10;&#10;            if inside_field and line.startswith('|'):&#10;                candidate_field += line + '\n'&#10;&#10;        return fields&#10;&#10;&#10;inputs = [&#10;    &quot;1 1&quot;, &quot;1 2&quot;, &quot;1 3&quot;,&#10;    &quot;2 1&quot;, &quot;2 2&quot;, &quot;2 3&quot;,&#10;    &quot;3 1&quot;, &quot;3 2&quot;, &quot;3 3&quot;&#10;]&#10;&#10;&#10;def iterate_cells(initial: str) -&gt; str:&#10;    index: int = -1&#10;    for i in range(len(inputs)):&#10;        if initial == inputs[i]:&#10;            index = i&#10;            break&#10;&#10;    if index == -1:&#10;        return ''&#10;&#10;    full_input: str = ''&#10;    for i in range(index, index + 9):&#10;        full_input += inputs[i % len(inputs)] + '\n'&#10;&#10;    return full_input&#10;&#10;&#10;class TicTacToeTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests: List[TestCase] = []&#10;&#10;        i: int = 0&#10;        for input in inputs:&#10;            full_move_input = iterate_cells(input)&#10;&#10;            str_nums = input.split()&#10;            x = int(str_nums[0])&#10;            y = int(str_nums[1])&#10;&#10;            if i % 2 == 1:&#10;                full_move_input = f'4 {i}\n' + full_move_input&#10;&#10;            full_game_input = ''&#10;            for _ in range(9):&#10;                full_game_input += full_move_input&#10;&#10;            if i % 2 == 0:&#10;                initial = &quot;start user easy\n&quot;&#10;            else:&#10;                initial = &quot;start easy user\n&quot;&#10;&#10;            full_game_input = initial + full_game_input + &quot;exit&quot;&#10;&#10;            tests += [TestCase(stdin=full_game_input)]&#10;&#10;            i += 1&#10;&#10;        tests += [TestCase(stdin=&quot;start easy easy\nexit&quot;)]&#10;&#10;        tests += [TestCase(stdin=&#10;                           &quot;start user user\n&quot; +&#10;                           &quot;1 1\n&quot; +&#10;                           &quot;2 2\n&quot; +&#10;                           &quot;1 2\n&quot; +&#10;                           &quot;2 1\n&quot; +&#10;                           &quot;1 3\n&quot; +&#10;                           &quot;exit&quot;)]&#10;&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: str) -&gt; CheckResult:&#10;&#10;        fields = TicTacToeField.parse_all(reply)&#10;&#10;        if len(fields) == 0:&#10;            return CheckResult.false(&#10;                &quot;No fields found&quot;&#10;            )&#10;&#10;        for i in range(1, len(fields)):&#10;            curr: TicTacToeField = fields[i - 1]&#10;            next: TicTacToeField = fields[i]&#10;&#10;            stayed = curr.equal_to(next)&#10;            improved = curr.has_next_as(next)&#10;&#10;            if not (stayed or improved):&#10;                return CheckResult.false(&#10;                    &quot;For two fields following each &quot; +&#10;                    &quot;other one is not a continuation &quot; +&#10;                    &quot;of the other.&quot;&#10;                )&#10;&#10;        return CheckResult.true()&#10;&#10;&#10;if __name__ == '__main__':&#10;    TicTacToeTest('tictactoe.tictactoe').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any, Dict&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    @staticmethod&#10;    def create_files(files: Dict[str, str]):&#10;        for file, content in files.items():&#10;            with open(file, 'w') as f:&#10;                f.write(content)&#10;&#10;    @staticmethod&#10;    def delete_files(files: Dict[str, str]):&#10;        for file in files.keys():&#10;            if os.path.isfile(file):&#10;                os.remove(file)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            self.create_files(test_case.files)&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            self.delete_files(test_case.files)&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tictactoe/tictactoe.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tictactoe/tictactoe.py" />
                                <option name="text" value="# write your code here&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561463823000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Let's write a &quot;medium&quot; level difficulty. Compared to randomly picking a cell to take a move, this level is considerably smarter.&lt;br&gt;&#10;  &lt;br&gt;&#10;  The &quot;medium&quot; level difficulty makes a move using the following process:&lt;/p&gt;&#10;&#10;&lt;ol&gt;&#10;  &lt;li&gt;If it can win in one move (if it has two in a row), it places a third to get three in a row and win.&lt;/li&gt;&#10;  &lt;li&gt;If the opponent can win in one move, it plays the third itself to block the opponent to win.&lt;/li&gt;&#10;  &lt;li&gt;Otherwise, it makes a random move.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&#10;&lt;p&gt;Despite the randomness of the third rule, this level is a lot harder to beat. This level stops all simple attempts to beat it due to the second rule, and always wins when it can due to the first rule.&lt;/p&gt;&#10;&#10;&lt;p&gt;You also should add &quot;medium&quot; parameter to be able to play against this level.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;The example below shows how your program should work.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Input command: start user medium&#10;---------&#10;|       |&#10;|       |&#10;|       |&#10;---------&#10;Enter the coordinates: 2 2&#10;---------&#10;|       |&#10;|   X   |&#10;|       |&#10;---------&#10;Making move level &quot;medium&quot;&#10;---------&#10;|       |&#10;|   X   |&#10;| O     |&#10;---------&#10;Enter the coordinates: 1 3&#10;---------&#10;| X     |&#10;|   X   |&#10;| O     |&#10;---------&#10;Making move level &quot;medium&quot;&#10;---------&#10;| X     |&#10;|   X   |&#10;| O   O |&#10;---------&#10;Enter the coordinates: 2 1&#10;---------&#10;| X     |&#10;|   X   |&#10;| O X O |&#10;---------&#10;Making move level &quot;medium&quot;&#10;---------&#10;| X O   |&#10;|   X   |&#10;| O X O |&#10;---------&#10;Enter the coordinates: 1 2&#10;---------&#10;| X O   |&#10;| X X   |&#10;| O X O |&#10;---------&#10;Making move level &quot;medium&quot;&#10;---------&#10;| X O   |&#10;| X X O |&#10;| O X O |&#10;---------&#10;Enter the coordinates: 3 3&#10;---------&#10;| X O X |&#10;| X X O |&#10;| O X O |&#10;---------&#10;Draw&#10;&#10;Input command: start medium user&#10;---------&#10;|       |&#10;|       |&#10;|       |&#10;---------&#10;Making move level &quot;medium&quot;&#10;---------&#10;|       |&#10;|       |&#10;|   X   |&#10;---------&#10;Enter the coordinates: 2 2&#10;---------&#10;|       |&#10;|   O   |&#10;|   X   |&#10;---------&#10;Making move level &quot;medium&quot;&#10;---------&#10;|       |&#10;|   O   |&#10;| X X   |&#10;---------&#10;Enter the coordinates: 3 1&#10;---------&#10;|       |&#10;|   O   |&#10;| X X O |&#10;---------&#10;Making move level &quot;medium&quot;&#10;---------&#10;| X     |&#10;|   O   |&#10;| X X O |&#10;---------&#10;Enter the coordinates: 1 2&#10;---------&#10;| X     |&#10;| O O   |&#10;| X X O |&#10;---------&#10;Making move level &quot;medium&quot;&#10;---------&#10;| X     |&#10;| O O X |&#10;| X X O |&#10;---------&#10;Enter the coordinates: 3 3&#10;---------&#10;| X   O |&#10;| O O X |&#10;| X X O |&#10;---------&#10;Making move level &quot;medium&quot;&#10;---------&#10;| X X O |&#10;| O O X |&#10;| X X O |&#10;---------&#10;Draw&#10;&#10;Input command: exit&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/73/stages/407/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6511" />
                      <option name="index" value="9" />
                      <option name="name" value="Make a &quot;medium&quot; difficulty level" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from enum import Enum&#10;from typing import List, Optional&#10;from copy import deepcopy&#10;&#10;&#10;class FieldState(Enum):&#10;    X = 'X'&#10;    O = 'O'&#10;    FREE = ' '&#10;&#10;&#10;def get_state(symbol):&#10;    if symbol == 'X':&#10;        return FieldState.X&#10;    elif symbol == 'O':&#10;        return FieldState.O&#10;    elif symbol == ' ':&#10;        return FieldState.FREE&#10;    else:&#10;        return None&#10;&#10;&#10;class TicTacToeField:&#10;&#10;    def __init__(self, *, field: str = '', constructed=None):&#10;&#10;        if constructed is not None:&#10;            self.field = deepcopy(constructed)&#10;&#10;        else:&#10;            self.field: List[List[Optional[FieldState]]] = [&#10;                [None for _ in range(3)] for _ in range(3)&#10;            ]&#10;&#10;            field = field.replace(&quot;\&quot;&quot;, &quot;&quot;)&#10;&#10;            for row in range(3):&#10;                for col in range(3):&#10;                    index = (2 - row) * 3 + col&#10;                    self.field[row][col] = get_state(field[index])&#10;&#10;    def equal_to(self, other) -&gt; bool:&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    return False&#10;        return True&#10;&#10;    def has_next_as(self, other) -&gt; bool:&#10;        improved: bool = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if self.field[i][j] == FieldState.FREE and not improved:&#10;                        improved = True&#10;                    else:&#10;                        return False&#10;        return improved&#10;&#10;    def differ_by_one(self, other) -&gt; bool:&#10;        have_single_difference = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if have_single_difference:&#10;                        return False&#10;                    have_single_difference = True&#10;        return have_single_difference&#10;&#10;    def is_close_to(self, other) -&gt; bool:&#10;        return (&#10;            self.equal_to(other)&#10;            or self.has_next_as(other)&#10;            or other.has_next_as(self)&#10;        )&#10;&#10;    @staticmethod&#10;    def parse(field_str: str):&#10;&#10;        lines = field_str.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if&#10;                 i.startswith('|') and i.endswith('|')]&#10;&#10;        for line in lines:&#10;            for c in line:&#10;                if c not in 'XO| ':&#10;                    return None&#10;&#10;        field: List[List[Optional[FieldState]]] = [&#10;            [None for _ in range(3)] for _ in range(3)&#10;        ]&#10;&#10;        y: int = 2&#10;&#10;        for line in lines:&#10;            cols = line[2], line[4], line[6]&#10;            x: int = 0&#10;            for c in cols:&#10;                state = get_state(c)&#10;                if state is None:&#10;                    return None&#10;                field[y][x] = state&#10;                x += 1&#10;            y -= 1&#10;&#10;        return TicTacToeField(constructed=field)&#10;&#10;    @staticmethod&#10;    def parse_all(output: str):&#10;        fields = []&#10;&#10;        lines = output.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if len(i) &gt; 0]&#10;&#10;        candidate_field = ''&#10;        inside_field = False&#10;        for line in lines:&#10;            if '----' in line and not inside_field:&#10;                inside_field = True&#10;                candidate_field = ''&#10;            elif '----' in line and inside_field:&#10;                field = TicTacToeField.parse(candidate_field)&#10;                if field is not None:&#10;                    fields += [field]&#10;                inside_field = False&#10;&#10;            if inside_field and line.startswith('|'):&#10;                candidate_field += line + '\n'&#10;&#10;        return fields&#10;&#10;&#10;inputs = [&#10;    &quot;1 1&quot;, &quot;1 2&quot;, &quot;1 3&quot;,&#10;    &quot;2 1&quot;, &quot;2 2&quot;, &quot;2 3&quot;,&#10;    &quot;3 1&quot;, &quot;3 2&quot;, &quot;3 3&quot;&#10;]&#10;&#10;&#10;def iterate_cells(initial: str) -&gt; str:&#10;    index: int = -1&#10;    for i in range(len(inputs)):&#10;        if initial == inputs[i]:&#10;            index = i&#10;            break&#10;&#10;    if index == -1:&#10;        return ''&#10;&#10;    full_input: str = ''&#10;    for i in range(index, index + 9):&#10;        full_input += inputs[i % len(inputs)] + '\n'&#10;&#10;    return full_input&#10;&#10;&#10;class TicTacToeTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests: List[TestCase] = []&#10;&#10;        i: int = 0&#10;        for input in inputs:&#10;            full_move_input = iterate_cells(input)&#10;&#10;            str_nums = input.split()&#10;            x = int(str_nums[0])&#10;            y = int(str_nums[1])&#10;&#10;            if i % 2 == 1:&#10;                full_move_input = f'4 {i}\n' + full_move_input&#10;&#10;            full_game_input = ''&#10;            for _ in range(9):&#10;                full_game_input += full_move_input&#10;&#10;            if i % 4 == 0:&#10;                initial = &quot;start user easy\n&quot;&#10;            elif i % 4 == 1:&#10;                initial = &quot;start easy user\n&quot;&#10;            elif i % 4 == 2:&#10;                initial = &quot;start user medium\n&quot;&#10;            else:&#10;                initial = &quot;start medium user\n&quot;&#10;&#10;            full_game_input = initial + full_game_input + &quot;exit&quot;&#10;&#10;            tests += [TestCase(stdin=full_game_input)]&#10;&#10;            i += 1&#10;&#10;        tests += [&#10;            TestCase(stdin=&quot;start easy easy\nexit&quot;),&#10;            TestCase(stdin=&quot;start medium medium\nexit&quot;),&#10;            TestCase(stdin=&quot;start medium easy\nexit&quot;),&#10;            TestCase(stdin=&quot;start easy medium\nexit&quot;),&#10;            TestCase(stdin=&#10;                     &quot;start user user\n&quot; +&#10;                     &quot;1 1\n&quot; +&#10;                     &quot;2 2\n&quot; +&#10;                     &quot;1 2\n&quot; +&#10;                     &quot;2 1\n&quot; +&#10;                     &quot;1 3\n&quot; +&#10;                     &quot;exit&quot;),&#10;        ]&#10;&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: str) -&gt; CheckResult:&#10;&#10;        fields = TicTacToeField.parse_all(reply)&#10;&#10;        if len(fields) == 0:&#10;            return CheckResult.false(&#10;                &quot;No fields found&quot;&#10;            )&#10;&#10;        for i in range(1, len(fields)):&#10;            curr: TicTacToeField = fields[i - 1]&#10;            next: TicTacToeField = fields[i]&#10;&#10;            stayed = curr.equal_to(next)&#10;            improved = curr.has_next_as(next)&#10;&#10;            if not (stayed or improved):&#10;                return CheckResult.false(&#10;                    &quot;For two fields following each &quot; +&#10;                    &quot;other one is not a continuation &quot; +&#10;                    &quot;of the other.&quot;&#10;                )&#10;&#10;        return CheckResult.true()&#10;&#10;&#10;if __name__ == '__main__':&#10;    TicTacToeTest('tictactoe.tictactoe').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any, Dict&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    @staticmethod&#10;    def create_files(files: Dict[str, str]):&#10;        for file, content in files.items():&#10;            with open(file, 'w') as f:&#10;                f.write(content)&#10;&#10;    @staticmethod&#10;    def delete_files(files: Dict[str, str]):&#10;        for file in files.keys():&#10;            if os.path.isfile(file):&#10;                os.remove(file)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            self.create_files(test_case.files)&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            self.delete_files(test_case.files)&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tictactoe/tictactoe.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tictactoe/tictactoe.py" />
                                <option name="text" value="# write your code here&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561463824000" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2 style=&quot;text-align: center;&quot;&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Let's write the &quot;hard&quot; level difficulty.&lt;/p&gt;&#10;&#10;&lt;p&gt;Compared to the &quot;medium&quot; level difficulty, this level not just go one move ahead to see an immediate win or prevent an immediate loss. This level can see two moves ahead, three moves ahead and so on. Basically, it can see all possible outcomes till the end of the game and choose the best of them considering his opponent also would play perfectly. So, it doesn't rely on the blunders of the opponent, it plays perfectly regardless of the opponent's skill.&lt;/p&gt;&#10;&#10;&lt;p&gt;The algorithm that implements this is called Minimax. This is the brute force algorithm that maximizes the value of the own position and minimizes the value of the opponent's position. It's not only an algorithm for Tic-Tac-Toe, but for every game with two players with alternate move order, for example, chess. You need to implement it as the &quot;hard&quot; difficulty level. &lt;a href=&quot;https://medium.freecodecamp.org/how-to-make-your-tic-tac-toe-game-unbeatable-by-using-the-minimax-algorithm-9d690bad4b37&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;This link&lt;/a&gt; will help to understand details.&lt;/p&gt;&#10;&#10;&lt;p&gt;You also should add &quot;hard&quot; parameter to be able to play against this level.&lt;/p&gt;&#10;&#10;&lt;h2 style=&quot;text-align: center;&quot;&gt;Output example&lt;/h2&gt;&#10;&#10;&lt;p&gt;The example below shows how your program should work.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;Input command: start hard user&#10;Making move level &quot;hard&quot;&#10;---------&#10;|       |&#10;| X     |&#10;|       |&#10;---------&#10;Enter the coordinates: 2 2&#10;---------&#10;|       |&#10;| X O   |&#10;|       |&#10;---------&#10;Making move level &quot;hard&quot;&#10;---------&#10;|   X   |&#10;| X O   |&#10;|       |&#10;---------&#10;Enter the coordinates: 2 1&#10;---------&#10;|   X   |&#10;| X O   |&#10;|   O   |&#10;---------&#10;Making move level &quot;hard&quot;&#10;---------&#10;| X X   |&#10;| X O   |&#10;|   O   |&#10;---------&#10;Enter the coordinates: 1 1&#10;---------&#10;| X X   |&#10;| X O   |&#10;| O O   |&#10;---------&#10;Making move level &quot;hard&quot;&#10;---------&#10;| X X X |&#10;| X O   |&#10;| O O   |&#10;---------&#10;X wins&#10;&#10;Input command: exit&lt;/code&gt;&lt;/pre&gt;&#10;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/73/stages/408/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6512" />
                      <option name="index" value="10" />
                      <option name="name" value="Make a &quot;hard&quot; difficulty level" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="stepikChangeStatus" value="Up to date" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from enum import Enum&#10;from typing import List, Optional&#10;from copy import deepcopy&#10;&#10;&#10;class FieldState(Enum):&#10;    X = 'X'&#10;    O = 'O'&#10;    FREE = ' '&#10;&#10;&#10;def get_state(symbol):&#10;    if symbol == 'X':&#10;        return FieldState.X&#10;    elif symbol == 'O':&#10;        return FieldState.O&#10;    elif symbol == ' ':&#10;        return FieldState.FREE&#10;    else:&#10;        return None&#10;&#10;&#10;class TicTacToeField:&#10;&#10;    def __init__(self, *, field: str = '', constructed=None):&#10;&#10;        if constructed is not None:&#10;            self.field = deepcopy(constructed)&#10;&#10;        else:&#10;            self.field: List[List[Optional[FieldState]]] = [&#10;                [None for _ in range(3)] for _ in range(3)&#10;            ]&#10;&#10;            field = field.replace(&quot;\&quot;&quot;, &quot;&quot;)&#10;&#10;            for row in range(3):&#10;                for col in range(3):&#10;                    index = (2 - row) * 3 + col&#10;                    self.field[row][col] = get_state(field[index])&#10;&#10;    def equal_to(self, other) -&gt; bool:&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    return False&#10;        return True&#10;&#10;    def has_next_as(self, other) -&gt; bool:&#10;        improved: bool = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if self.field[i][j] == FieldState.FREE and not improved:&#10;                        improved = True&#10;                    else:&#10;                        return False&#10;        return improved&#10;&#10;    def differ_by_one(self, other) -&gt; bool:&#10;        have_single_difference = False&#10;        for i in range(3):&#10;            for j in range(3):&#10;                if self.field[i][j] != other.field[i][j]:&#10;                    if have_single_difference:&#10;                        return False&#10;                    have_single_difference = True&#10;        return have_single_difference&#10;&#10;    def is_close_to(self, other) -&gt; bool:&#10;        return (&#10;            self.equal_to(other)&#10;            or self.has_next_as(other)&#10;            or other.has_next_as(self)&#10;        )&#10;&#10;    @staticmethod&#10;    def parse(field_str: str):&#10;&#10;        lines = field_str.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if&#10;                 i.startswith('|') and i.endswith('|')]&#10;&#10;        for line in lines:&#10;            for c in line:&#10;                if c not in 'XO| ':&#10;                    return None&#10;&#10;        field: List[List[Optional[FieldState]]] = [&#10;            [None for _ in range(3)] for _ in range(3)&#10;        ]&#10;&#10;        y: int = 2&#10;&#10;        for line in lines:&#10;            cols = line[2], line[4], line[6]&#10;            x: int = 0&#10;            for c in cols:&#10;                state = get_state(c)&#10;                if state is None:&#10;                    return None&#10;                field[y][x] = state&#10;                x += 1&#10;            y -= 1&#10;&#10;        return TicTacToeField(constructed=field)&#10;&#10;    @staticmethod&#10;    def parse_all(output: str):&#10;        fields = []&#10;&#10;        lines = output.splitlines()&#10;        lines = [i.strip() for i in lines]&#10;        lines = [i for i in lines if len(i) &gt; 0]&#10;&#10;        candidate_field = ''&#10;        inside_field = False&#10;        for line in lines:&#10;            if '----' in line and not inside_field:&#10;                inside_field = True&#10;                candidate_field = ''&#10;            elif '----' in line and inside_field:&#10;                field = TicTacToeField.parse(candidate_field)&#10;                if field is not None:&#10;                    fields += [field]&#10;                inside_field = False&#10;&#10;            if inside_field and line.startswith('|'):&#10;                candidate_field += line + '\n'&#10;&#10;        return fields&#10;&#10;&#10;inputs = [&#10;    &quot;1 1&quot;, &quot;1 2&quot;, &quot;1 3&quot;,&#10;    &quot;2 1&quot;, &quot;2 2&quot;, &quot;2 3&quot;,&#10;    &quot;3 1&quot;, &quot;3 2&quot;, &quot;3 3&quot;&#10;]&#10;&#10;&#10;def iterate_cells(initial: str) -&gt; str:&#10;    index: int = -1&#10;    for i in range(len(inputs)):&#10;        if initial == inputs[i]:&#10;            index = i&#10;            break&#10;&#10;    if index == -1:&#10;        return ''&#10;&#10;    full_input: str = ''&#10;    for i in range(index, index + 9):&#10;        full_input += inputs[i % len(inputs)] + '\n'&#10;&#10;    return full_input&#10;&#10;&#10;class TicTacToeTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests: List[TestCase] = []&#10;&#10;        i: int = 0&#10;        for input in inputs:&#10;            full_move_input = iterate_cells(input)&#10;&#10;            str_nums = input.split()&#10;            x = int(str_nums[0])&#10;            y = int(str_nums[1])&#10;&#10;            if i % 2 == 1:&#10;                full_move_input = f'4 {i}\n' + full_move_input&#10;&#10;            full_game_input = ''&#10;            for _ in range(9):&#10;                full_game_input += full_move_input&#10;&#10;            if i % 6 == 0:&#10;                initial = &quot;start user easy\n&quot;&#10;            elif i % 6 == 1:&#10;                initial = &quot;start easy user\n&quot;&#10;            elif i % 6 == 2:&#10;                initial = &quot;start user medium\n&quot;&#10;            elif i % 6 == 3:&#10;                initial = &quot;start medium user\n&quot;&#10;            elif i % 6 == 4:&#10;                initial = &quot;start user hard\n&quot;&#10;            else:&#10;                initial = &quot;start hard user\n&quot;&#10;&#10;            full_game_input = initial + full_game_input + &quot;exit&quot;&#10;&#10;            tests += [TestCase(stdin=full_game_input)]&#10;&#10;            i += 1&#10;&#10;        tests += [&#10;            TestCase(stdin=&quot;start easy easy\nexit&quot;),&#10;            TestCase(stdin=&quot;start medium medium\nexit&quot;),&#10;            TestCase(stdin=&quot;start hard hard\nexit&quot;),&#10;&#10;            TestCase(stdin=&quot;start medium easy\nexit&quot;),&#10;            TestCase(stdin=&quot;start easy medium\nexit&quot;),&#10;&#10;            TestCase(stdin=&quot;start medium hard\nexit&quot;),&#10;            TestCase(stdin=&quot;start hard medium\nexit&quot;),&#10;&#10;            TestCase(stdin=&quot;start easy hard\nexit&quot;),&#10;            TestCase(stdin=&quot;start hard easy\nexit&quot;),&#10;&#10;            TestCase(stdin=&#10;                     &quot;start user user\n&quot; +&#10;                     &quot;1 1\n&quot; +&#10;                     &quot;2 2\n&quot; +&#10;                     &quot;1 2\n&quot; +&#10;                     &quot;2 1\n&quot; +&#10;                     &quot;1 3\n&quot; +&#10;                     &quot;exit&quot;),&#10;        ]&#10;&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: str) -&gt; CheckResult:&#10;&#10;        fields = TicTacToeField.parse_all(reply)&#10;&#10;        if len(fields) == 0:&#10;            return CheckResult.false(&#10;                &quot;No fields found&quot;&#10;            )&#10;&#10;        for i in range(1, len(fields)):&#10;            curr: TicTacToeField = fields[i - 1]&#10;            next: TicTacToeField = fields[i]&#10;&#10;            stayed = curr.equal_to(next)&#10;            improved = curr.has_next_as(next)&#10;&#10;            if not (stayed or improved):&#10;                return CheckResult.false(&#10;                    &quot;For two fields following each &quot; +&#10;                    &quot;other one is not a continuation &quot; +&#10;                    &quot;of the other.&quot;&#10;                )&#10;&#10;        return CheckResult.true()&#10;&#10;&#10;if __name__ == '__main__':&#10;    TicTacToeTest('tictactoe.tictactoe').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_case.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_case.py" />
                                <option name="text" value="from typing import List, Dict, Any, Tuple&#10;&#10;&#10;class TestCase:&#10;&#10;    def __init__(self, *, stdin='', args=None,&#10;                 attach=None, files=None, copy_to_attach=False):&#10;        self.input: str = stdin&#10;        self.args: List[str] = [] if args is None else args&#10;        self.attach: Any = attach&#10;        self.files: Dict[str, str] = {} if files is None else files&#10;        if copy_to_attach:&#10;            self.attach = stdin&#10;&#10;    @staticmethod&#10;    def from_stepik(stepik_tests: List[Tuple[str, Any]]) -&gt; List['TestCase']:&#10;        hs_tests = []&#10;        for test in stepik_tests:&#10;            hs_test = TestCase()&#10;            if type(hs_test) is list:&#10;                hs_test.input = test[0]&#10;                hs_test.attach = test[1]&#10;            elif type(hs_test) is str:&#10;                hs_test.input = test&#10;            else:&#10;                raise ValueError(&quot;Bad test: &quot; + str(test))&#10;            hs_tests += [hs_test]&#10;        return hs_tests&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/exceptions.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/exceptions.py" />
                                <option name="text" value="&#10;class BadSolutionException(Exception):&#10;    def __init__(self, message):&#10;        self.message = message&#10;&#10;&#10;class SyntaxException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;&#10;&#10;class ExitException(BadSolutionException):&#10;    def __init__(self, message):&#10;        super().__init__(message)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/stage_test.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/stage_test.py" />
                                <option name="text" value="import sys&#10;import runpy&#10;import os&#10;import io&#10;import importlib&#10;import signal&#10;import builtins&#10;import traceback&#10;from typing import List, Any, Dict&#10;from hstest.test_helper import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;from hstest.exceptions import *&#10;&#10;&#10;class StageTest:&#10;&#10;    real_stdin = None&#10;    real_print = None&#10;    real_input = None&#10;    user_output: io.StringIO = None&#10;&#10;    @staticmethod&#10;    def remove_kill_methods():&#10;        os.kill = lambda *x, **y: exit(0)&#10;        os._exit = lambda *x, **y: exit(0)&#10;        os.killpg = lambda *x, **y: exit(0)&#10;        signal.pthread_kill = lambda *x, **y: exit(0)&#10;        signal.siginterrupt = lambda *x, **y: exit(0)&#10;&#10;    @staticmethod&#10;    def set_input(user_input: str):&#10;        sys.stdin = io.StringIO(user_input)&#10;&#10;    @staticmethod&#10;    def add_input(user_input: str):&#10;        sys.stdin: io.StringIO&#10;        curr_position = sys.stdin.seek(0, io.SEEK_CUR)&#10;        sys.stdin.seek(0)&#10;        sys.stdin = io.StringIO(sys.stdin.read() + user_input)&#10;        sys.stdin.seek(curr_position)&#10;&#10;    @staticmethod&#10;    def print(*args, **kwargs):&#10;        StageTest.real_print(*args, **kwargs)&#10;        StageTest.real_print(*args, **kwargs, file=StageTest.user_output)&#10;&#10;    @staticmethod&#10;    def input(arg=''):&#10;        StageTest.print(arg, end='')&#10;        user_input = StageTest.real_input()&#10;        StageTest.print()&#10;        return user_input&#10;&#10;    @staticmethod&#10;    def replace_globals():&#10;        StageTest.real_stdin = sys.stdin&#10;        StageTest.real_print = builtins.print&#10;        StageTest.real_input = builtins.input&#10;        builtins.print = StageTest.print&#10;        builtins.input = StageTest.input&#10;&#10;    @staticmethod&#10;    def get_print_back():&#10;        builtins.print = StageTest.real_print&#10;        sys.stdin = StageTest.real_stdin&#10;&#10;    def __init__(self, module_to_test: str):&#10;        self.remove_kill_methods()&#10;        self.replace_globals()&#10;        self.module_to_test = module_to_test&#10;        self.this_test_file = __file__&#10;        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'&#10;        self.full_file_to_test = ''&#10;        self.tests: List[TestCase] = []&#10;&#10;    def reset(self):&#10;        StageTest.user_output = io.StringIO()&#10;        top_module = self.module_to_test[:self.module_to_test.index('.')]&#10;        for name, module in sys.modules.items():&#10;            if name.startswith(top_module):&#10;                importlib.reload(module)&#10;&#10;    @staticmethod&#10;    def create_files(files: Dict[str, str]):&#10;        for file, content in files.items():&#10;            with open(file, 'w') as f:&#10;                f.write(content)&#10;&#10;    @staticmethod&#10;    def delete_files(files: Dict[str, str]):&#10;        for file in files.keys():&#10;            if os.path.isfile(file):&#10;                os.remove(file)&#10;&#10;    def test(self, test_case: TestCase) -&gt; str:&#10;        self.reset()&#10;        try:&#10;            self.create_files(test_case.files)&#10;            sys.argv = [self.file_to_test] + test_case.args&#10;            self.set_input(test_case.input)&#10;            runpy.run_module(&#10;                self.module_to_test,&#10;                run_name=&quot;__main__&quot;&#10;            )&#10;            self.delete_files(test_case.files)&#10;            return StageTest.user_output.getvalue()&#10;        except SyntaxError as e:&#10;&#10;            file = e.filename&#10;            file = file.replace(os.sep, '.')&#10;            file = file[file.index(self.module_to_test):-3]&#10;            file = file.replace('.', os.sep) + '.py'&#10;&#10;            output = f'File &quot;{file}&quot;, line {e.lineno}\n' \&#10;                     + e.text.strip()[: e.offset-1] + '\n' \&#10;                     'SyntaxError: invalid syntax'&#10;&#10;            # '`' * (e.offset - 2) + '^'&#10;&#10;            raise SyntaxException(output)&#10;&#10;        except (SystemExit, KeyboardInterrupt):&#10;            raise ExitException('Tried to exit.')&#10;&#10;    def generate(self) -&gt; List[TestCase]:&#10;        raise NotImplemented&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        raise NotImplemented&#10;&#10;    def get_stacktrace(self, hide_internals, skipped_traces=0):&#10;&#10;        if self.full_file_to_test != '':&#10;            common_prefix = os.path.commonpath([&#10;                self.full_file_to_test, self.this_test_file&#10;            ])&#10;        else:&#10;            common_prefix = ''&#10;&#10;        exc_type, exc_obj, exc_tb = sys.exc_info()&#10;&#10;        if hide_internals and skipped_traces != 0:&#10;            traceback_msg = 'Traceback (most recent call last):\n'&#10;        else:&#10;            traceback_msg = ''&#10;&#10;        for line in traceback.TracebackException(&#10;                type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):&#10;            if not hide_internals:&#10;                traceback_msg += line&#10;            elif skipped_traces &gt;= 0:&#10;                skipped_traces -= 1&#10;            elif self.this_test_file not in line:&#10;                traceback_msg += line.replace(common_prefix + os.sep, '')&#10;&#10;        return traceback_msg&#10;&#10;    def run_tests(self):&#10;&#10;        test_number = 0&#10;        try:&#10;            for test in self.generate():&#10;                test_number += 1&#10;                reply = self.test(test)&#10;                result = self.check(reply, test.attach)&#10;                if not result.result:&#10;                    fail_msg = f'Wrong answer in test #{test_number}'&#10;                    self.get_print_back()&#10;                    failed(fail_msg + '\n\n' + result.feedback)&#10;                    break&#10;&#10;        except SyntaxException as ex:&#10;            self.get_print_back()&#10;            failed(ex.message)&#10;&#10;        except ExitException as ex:&#10;            error_msg = f'Error in test #{test_number}'&#10;            self.get_print_back()&#10;            failed(error_msg + '\n\n' + ex.message)&#10;&#10;        except Exception:&#10;&#10;            exc_type, exc_obj, exc_tb = sys.exc_info()&#10;            trace_frames = []&#10;&#10;            user_trace_started = False&#10;            skipped_traces = 0&#10;            while exc_tb is not None:&#10;                code = exc_tb.tb_frame.f_code&#10;                filename = code.co_filename&#10;&#10;                if filename.endswith(self.file_to_test) and not user_trace_started:&#10;                    user_trace_started = True&#10;                    self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename&#10;&#10;                if user_trace_started:&#10;                    trace_frames += [exc_tb.tb_frame.f_code]&#10;                else:&#10;                    skipped_traces += 1&#10;&#10;                exc_tb = exc_tb.tb_next&#10;&#10;            if not trace_frames:&#10;                exception_msg = (&#10;                        f&quot;Fatal error in test #{test_number}, &quot; +&#10;                        &quot;please send the report to Hyperskill team.&quot;&#10;                )&#10;                stacktrace = self.get_stacktrace(hide_internals=False)&#10;&#10;            else:&#10;                exception_msg = f'Exception in test #{test_number}'&#10;                stacktrace = self.get_stacktrace(&#10;                    hide_internals=True,&#10;                    skipped_traces=skipped_traces&#10;                )&#10;&#10;            self.get_print_back()&#10;            failed(exception_msg + '\n\n' + stacktrace)&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/test_helper.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/test_helper.py" />
                                <option name="text" value="import sys&#10;&#10;&#10;def get_file_text(path):&#10;    &quot;&quot;&quot; Returns file text by path&quot;&quot;&quot;&#10;    file_io = open(path, &quot;r&quot;)&#10;    text = file_io.read()&#10;    file_io.close()&#10;    return text&#10;&#10;&#10;def get_file_output(encoding=&quot;utf-8&quot;, path=sys.argv[-1], arg_string=&quot;&quot;):&#10;    &quot;&quot;&quot;&#10;    Returns answer file output&#10;    :param encoding: to decode output in python3&#10;    :param path: path of file to execute&#10;    :return: list of strings&#10;    &quot;&quot;&quot;&#10;    import subprocess&#10;&#10;    proc = subprocess.Popen([sys.executable, path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,&#10;                            stderr=subprocess.STDOUT)&#10;    if arg_string:&#10;        for arg in arg_string.split(&quot;\n&quot;):&#10;            proc.stdin.write(bytearray(str(arg) + &quot;\n&quot;, encoding))&#10;            proc.stdin.flush()&#10;&#10;    return list(map(lambda x: str(x.decode(encoding)), proc.communicate()[0].splitlines()))&#10;&#10;&#10;def test_file_importable():&#10;    &quot;&quot;&quot; Tests there is no obvious syntax errors&quot;&quot;&quot;&#10;    path = sys.argv[-1] + '1'&#10;&#10;    print(path)&#10;&#10;    if not path.endswith(&quot;.py&quot;):&#10;        import os&#10;&#10;        parent = os.path.abspath(os.path.join(path, os.pardir))&#10;        python_files = [f for f in os.listdir(parent)&#10;                        if os.path.isfile(os.path.join(parent, f)) and f.endswith(&quot;.py&quot;)]&#10;&#10;        failed('\n'.join(python_files))&#10;&#10;        for python_file in python_files:&#10;            if python_file == &quot;tests.py&quot;:&#10;                continue&#10;&#10;            check_importable_path(os.path.join(parent, python_file))&#10;        return&#10;    check_importable_path(path)&#10;&#10;&#10;def check_importable_path(path):&#10;    &quot;&quot;&quot; Checks that file is importable.&#10;        Reports failure otherwise.&#10;    &quot;&quot;&quot;&#10;    saved_input = patch_input()&#10;    try:&#10;        import_file(path)&#10;    except:&#10;        failed(&quot;The file contains syntax errors&quot;, test_file_importable.__name__)&#10;        return&#10;    finally:&#10;        revert_input(saved_input)&#10;&#10;    passed(test_file_importable.__name__)&#10;&#10;&#10;def patch_input():&#10;    def mock_fun(_m=&quot;&quot;):&#10;        return &quot;mock&quot;&#10;&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        save_input = builtins.input&#10;        builtins.input = mock_fun&#10;        return save_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        save_input = __builtin__.raw_input&#10;        __builtin__.raw_input = mock_fun&#10;        __builtin__.input = mock_fun&#10;        return save_input&#10;&#10;&#10;def revert_input(saved_input):&#10;    if sys.version_info[0] == 3:&#10;        import builtins&#10;        builtins.input = saved_input&#10;    elif sys.version_info[0] == 2:&#10;        import __builtin__&#10;        __builtin__.raw_input = saved_input&#10;        __builtin__.input = saved_input&#10;&#10;&#10;def import_file(path):&#10;    &quot;&quot;&quot; Returns imported file &quot;&quot;&quot;&#10;    if sys.version_info[0] == 2 or sys.version_info[1] &lt; 3:&#10;        import imp&#10;&#10;        return imp.load_source(&quot;tmp&quot;, path)&#10;    elif sys.version_info[0] == 3:&#10;        import importlib.machinery&#10;&#10;        return importlib.machinery.SourceFileLoader(&quot;tmp&quot;, path).load_module(&quot;tmp&quot;)&#10;&#10;&#10;def import_task_file():&#10;    &quot;&quot;&quot; Returns imported file.&#10;        Imports file from which check action was run&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    return import_file(path)&#10;&#10;&#10;def test_is_not_empty():&#10;    &quot;&quot;&quot;&#10;        Checks that file is not empty&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if len(file_text) &gt; 0:&#10;        passed()&#10;    else:&#10;        failed(&quot;The file is empty. Please, reload the task and try again.&quot;)&#10;&#10;&#10;def test_text_equals(text, error_text):&#10;    &quot;&quot;&quot;&#10;        Checks that answer equals text.&#10;    &quot;&quot;&quot;&#10;    path = sys.argv[-1]&#10;    file_text = get_file_text(path)&#10;&#10;    if file_text.strip() == text:&#10;        passed()&#10;    else:&#10;        failed(error_text)&#10;&#10;&#10;def set_congratulation_message(message):&#10;    &quot;&quot;&quot; Overrides default 'Congratulations!' message &quot;&quot;&quot;&#10;    print(&quot;#educational_plugin CONGRATS_MESSAGE &quot; + message)&#10;&#10;&#10;def failed(message: str):&#10;    &quot;&quot;&quot; Reports failure &quot;&quot;&quot;&#10;    lines = message.splitlines()&#10;    print(&quot;\n#educational_plugin FAILED + &quot; + lines[0])&#10;    for line in lines[1:]:&#10;        print(&quot;#educational_plugin &quot; + line)&#10;&#10;&#10;def passed(name=None):&#10;    &quot;&quot;&quot; Reports success &quot;&quot;&quot;&#10;    if not name:&#10;        name = sys._getframe().f_back.f_code.co_name&#10;    print(&quot;#educational_plugin &quot; + name + &quot; test OK&quot;)&#10;&#10;&#10;def check_samples(samples=()):&#10;    &quot;&quot;&quot;&#10;      Check script output for all samples. Sample is a two element list, where the first is input and&#10;      the second is output.&#10;    &quot;&quot;&quot;&#10;    for sample in samples:&#10;        if len(sample) == 2:&#10;            output = get_file_output(arg_string=str(sample[0]))&#10;            if &quot;\n&quot;.join(output) != sample[1]:&#10;                failed(&#10;                    &quot;Test from samples failed: \n \n&quot;&#10;                    &quot;Input:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Expected:\n{}&quot;&#10;                    &quot;\n \n&quot;&#10;                    &quot;Your result:\n{}&quot;.format(str.strip(sample[0]), str.strip(sample[1]), &quot;\n&quot;.join(output)))&#10;                return&#10;        set_congratulation_message(&quot;All test from samples passed. Now we are checking your solution on Stepik server.&quot;)&#10;&#10;    passed()&#10;&#10;&#10;def run_common_tests(error_text=&quot;Please, reload file and try again&quot;):&#10;    test_is_not_empty()&#10;    test_file_importable()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hstest/check_result.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hstest/check_result.py" />
                                <option name="text" value="class CheckResult:&#10;&#10;    def __init__(self, result: bool, feedback: str):&#10;        self.result = result&#10;        self.feedback = feedback&#10;&#10;    @staticmethod&#10;    def true():&#10;        return CheckResult(True, '')&#10;&#10;    @staticmethod&#10;    def false(feedback: str = ''):&#10;        return CheckResult(False, feedback)&#10;&#10;&#10;def wrong(feedback: str = '') -&gt; CheckResult:&#10;    return CheckResult.false(feedback)&#10;&#10;&#10;def accept():&#10;    return CheckResult.true()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="tictactoe/tictactoe.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tictactoe/tictactoe.py" />
                                <option name="text" value="# write your code here&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="trackLengths" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" value="1561463825000" />
                    </EduTask>
                  </list>
                </option>
              </FrameworkLesson>
            </list>
          </option>
        </HyperskillCourse>
      </option>
    </StudyTaskManager>
  </component>
</project>